# A0130949Y
###### src\logic\AddTask.java
``` java

import model.Task;
import org.ocpsoft.prettytime.shade.org.apache.commons.lang.NullArgumentException;

import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

public class AddTask<E> implements Command<Object> {
    private static Logger loggerAdd = Logger.getLogger("log");
    private Stack<Task> undoTaskStack = new Stack<Task>();
    private Stack<Integer> undoStackInt = new Stack<Integer>();
    private Stack<Task> redoTaskStack = new Stack<Task>();
    private Stack<Integer> redoStackInt = new Stack<Integer>();

    @Override
    // adds the task into the list. task cannot be null. throwing Exception is for Junit testing
    public void execute(List<Task> list, Object task) {
        loggerAdd.log(Level.INFO, "Start adding task");
        try {
            assert (task != null);
            executeAddTask(list, (Task) task);
        } catch (AssertionError e) {
            loggerAdd.log(Level.WARNING, "Task is null");
            throw new NullArgumentException("For add test");
        }
        loggerAdd.log(Level.INFO, "End");
    }

    private void executeAddTask(List<Task> list, Task task) {
        list.add(task);
        undoTaskStack.push(task);
        Collections.sort(list);
        int index = findTask(task.getId(), (ArrayList<Task>) list);
        undoStackInt.push(index);
    }

    @Override
    public void undo(ArrayList<Task> list) {
        loggerAdd.log(Level.INFO, "START ADD UNDO PROCESS");
        try {
            undoAdding(list);
            loggerAdd.log(Level.INFO, "UNDO COMPELETED");
        } catch (EmptyStackException e) {
            loggerAdd.log(Level.WARNING, "ERROR, ADD UNDO HAS AN ERROR");
        } catch (Exception e) {
            System.out.println(e);
        }
        loggerAdd.log(Level.INFO, "END");
    }

    // removing the added task
    private void undoAdding(ArrayList<Task> list) {
        Task undoTask = undoTaskStack.pop();
        int index = undoStackInt.pop();
        addRedoStack(undoTask, index);
        list.remove(index);
    }

    private void addRedoStack(Task undoTask, int index) {
        redoTaskStack.push(undoTask);
        redoStackInt.push(index);
    }

    @Override
    public int findTask(String id, ArrayList<Task> list) {
        final int INVALID = -1;
        int position = INVALID;
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).getId().equals(id)) {
                position = i;
            }
        }
        return position;
    }

    @Override
    public void redo(ArrayList<Task> list) {
        loggerAdd.log(Level.INFO, "START REDO PROCESS");
        try {
            redoAdding(list);
        } catch (EmptyStackException e) {
            loggerAdd.log(Level.WARNING, "ERROR, ADD REDO HAS AN ERROR");
        } catch (Exception e) {
            System.out.println(e);
        }
        loggerAdd.log(Level.INFO, "FINISH REDO PROCESS");
    }

    // add the task again
    private void redoAdding(ArrayList<Task> list) {
        Task redoTask = redoTaskStack.pop();
        int index = redoStackInt.pop();
        addUndoStack(redoTask, index);
        list.add(index, redoTask);
    }

    private void addUndoStack(Task redoTask, int index) {
        undoTaskStack.push(redoTask);
        undoStackInt.push(index);
    }
}
```
###### src\logic\ClearTasks.java
``` java

import model.Task;

import java.util.ArrayList;
import java.util.List;

public class ClearTasks<E> implements Command<Object> {
    private ArrayList<Task> tasks = new ArrayList<Task>();

    @Override
    public void execute(List<Task> list, Object op) {
        executeClear(list);
    }

    // transfer the current list to a new list for undo proposes
    private void executeClear(List<Task> list) {
        tasks.clear();
        for (int i = 0; i < list.size(); i++) {
            tasks.add(list.get(i));
        }
        list.clear();
    }

    @Override
    public void undo(ArrayList<Task> list) {
        list.clear();
        for (int i = 0; i < tasks.size(); i++) {
            list.add(tasks.get(i));
        }
    }

    @Override
    public void redo(ArrayList<Task> list) {
        list.clear();
    }

    @Override
    public int findTask(String id, ArrayList<Task> list) {
        return 0;
    }
}
```
###### src\logic\Command.java
``` java

import model.Task;

import java.util.ArrayList;
import java.util.List;

public interface Command<E> {
    void execute(List<Task> list, E op);

    void undo(ArrayList<Task> list);

    void redo(ArrayList<Task> list);

    int findTask(String id, ArrayList<Task> list);
}
```
###### src\logic\DeleteTask.java
``` java

import model.Task;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

public class DeleteTask<E> implements Command<Object> {
    private static Logger loggerDelete = Logger.getLogger("log");
    private static Stack<Task> undoStackTask = new Stack<Task>();
    private static Stack<Task> redoTaskStack = new Stack<Task>();

    @Override
    // deletes a task from that index. exceptions are thrown for Junit tests.
    public void execute(List<Task> list, Object index) {
        loggerDelete.log(Level.INFO, "Start logging for delete");
        try {
            int taskIndex = (int) index;
            assert (taskIndex >= 0);
            executeDelete(list, taskIndex);
        } catch (AssertionError e) {
            loggerDelete.log(Level.WARNING, "Index is negative");
            throw new IllegalArgumentException();
        } catch (NumberFormatException e) {
            loggerDelete.log(Level.WARNING, "Index is not a number");
            throw new NumberFormatException();
        } catch (ArrayIndexOutOfBoundsException e) {
            loggerDelete.log(Level.WARNING, "Index is out of range");
            throw new ArrayIndexOutOfBoundsException();
        }
        loggerDelete.log(Level.INFO, "End");
    }

    private void executeDelete(List<Task> list, int index) {
        undoStackTask.push(list.get(index));
        list.remove(index);
    }

    @Override
    // takes out the deleted task and add back in
    public void undo(ArrayList<Task> list) {
        loggerDelete.log(Level.INFO, "Start undo process for deleting");
        try {
            Task deletedTask = undoStackTask.pop();
            redoTaskStack.push(deletedTask);
            list.add(deletedTask);
        } catch (Exception e) {
            loggerDelete.log(Level.WARNING, "Error in undo-ing the delete", e);
        }
        loggerDelete.log(Level.INFO, "End");
    }

    @Override
    // takes out the previous-deleted-but-added-back-in task from the redoTaskStack and remove it from the list
    public void redo(ArrayList<Task> list) {
        loggerDelete.log(Level.INFO, "Start redo process for deleting");
        try {
            Task redoTask = redoTaskStack.pop();
            int indexToRedo = findTask(redoTask.getId(), list);
            undoStackTask.push(redoTask);
            list.remove(indexToRedo);
        } catch (Exception e) {
            loggerDelete.log(Level.WARNING, "Error in redo-ing the delete", e);
        }
        loggerDelete.log(Level.INFO, "End");
    }

    @Override
    public int findTask(String id, ArrayList<Task> list) {
        final int INVALID = -1;
        int position = INVALID;
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).getId().equals(id)) {
                position = i;
            }
        }
        return position;
    }
}
```
###### src\logic\Logic.java
``` java

import data.DataHandler;
import data.JsonDataHandler;
import data.SettingManager;
import data.SettingManagerImpl;
import model.RecurringTask;
import model.Task;
import parser.Commands;

import java.util.*;
import java.util.logging.Logger;

public class Logic {
    protected List<Task> list;
    protected List<Task> archivedList;
    protected TreeMap<Commands, Command> commandMap;
    private DataHandler storage;
    protected Stack<Commands> undoStack;
    protected Stack<Commands> redoStack;
    private SettingManager settings;
    public static final Logger logger = Logger.getLogger(Logic.class.getName());

    public Logic() {
        init();
    }

    private void init() {
        initializeVariables();
        loadSavedTask();
    }

    private void initializeVariables() {
        populateCommandMap();
        initLists();
        assert (list != null);
        settings = new SettingManagerImpl();
        storage = new JsonDataHandler();
        initStacks();
    }

    private void initLists() {
        list = new ArrayList<Task>();
        archivedList = new ArrayList<Task>();
    }

    private void initStacks() {
        undoStack = new Stack<Commands>();
        redoStack = new Stack<Commands>();
    }

    // get size of the list. use for testing
    public int getSize() {
        assert (list.size() >= 0);
        return list.size();
    }

    public ArrayList<Task> getTasks() {
        return (ArrayList<Task>) list;
    }

    public ArrayList<Task> getArchivedTasks() {
        return (ArrayList<Task>) archivedList;
    }

    private void populateCommandMap() {
        commandMap = new TreeMap<Commands, Command>();
        commandMap.put(Commands.CREATE_TASK, new AddTask());
        commandMap.put(Commands.DELETE_TASK, new DeleteTask());
        commandMap.put(Commands.UPDATE_TASK, new UpdateTask());
        commandMap.put(Commands.SKIP_TASK, new SkipRecurTask());
        commandMap.put(Commands.STOP_TASK, new StopRecurTask());
        commandMap.put(Commands.MARK_TASK, new MarkTask());
        commandMap.put((Commands.CLEAR_TASK), new ClearTasks());
    }

    public ArrayList<Task> clear() {
        commandMap.get(Commands.CLEAR_TASK).execute(list, "");
        manageStacks(Commands.CLEAR_TASK);
        return (ArrayList<Task>) list;
    }

    public void adjustmentForRecurringTasks() {
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i) instanceof RecurringTask) {
                ((RecurringTask) list.get(i)).adjustDate();
            }
        }
    }

    public void loadSavedTask() {
        list = storage.getTasks();
        adjustmentForRecurringTasks();
        saveList();
    }

    public void exit() {
        saveList();
        System.exit(0);
    }

    public ArrayList<Task> addTask(Task task) {
        commandMap.get(Commands.CREATE_TASK).execute(list, task);
        manageStacks(Commands.CREATE_TASK);
        saveList();
        return (ArrayList<Task>) list;
    }

    public void manageStacks(Commands command) {
        undoStack.push(command);
        redoStack.clear();
    }

    public ArrayList<Task> deleteTask(int index) {
        commandMap.get(Commands.DELETE_TASK).execute(list, index);
        manageStacks(Commands.DELETE_TASK);
        saveList();
        return (ArrayList<Task>) list;
    }

    public ArrayList<Task> updateTask(Task task, int index) {
        list.add(task);
        commandMap.get(Commands.UPDATE_TASK).execute(list, index);
        manageStacks(Commands.UPDATE_TASK);
        saveList();
        return (ArrayList<Task>) list;
    }

    public ArrayList<Task> undo() {
        Commands command = undoStack.pop();
        redoStack.push(command);
        commandMap.get(command).undo((ArrayList<Task>) list);
        System.out.println("undo " + command);
        Collections.sort(list);
        return (ArrayList<Task>) list;
    }

    public ArrayList<Task> redo() {
        Commands command = redoStack.pop();
        undoStack.push(command);
        commandMap.get(command).redo((ArrayList<Task>) list);
        System.out.println("redo " + command);
        Collections.sort(list);
        return (ArrayList<Task>) list;
    }

    public ArrayList<Task> skip(int index) {
        if (list.get(index) instanceof RecurringTask) {
            commandMap.get(Commands.SKIP_TASK).execute(list, index);
            manageStacks(Commands.SKIP_TASK);
            saveList();
        }
        return (ArrayList<Task>) list;
    }

    // mark uses this version of skip so that the undoStack does not take in skip command
    public void skipForMark(int index) {
        if (list.get(index) instanceof RecurringTask) {
            commandMap.get(Commands.SKIP_TASK).execute(list, index);
            saveList();
        }
    }

    public ArrayList<Task> stopRecurring(int index) {
        if (list.get(index) instanceof RecurringTask) {
            commandMap.get(Commands.STOP_TASK).execute(list, index);
            manageStacks(Commands.STOP_TASK);
            saveList();
        }
        saveList();
        return (ArrayList<Task>) list;
    }

    public void markAsDone(String taskId) {
        shiftCompletedTaskToArchivedList(taskId);
        saveList();
    }

    // recurring task requires cloning as the task remains in the list
    private void shiftCompletedTaskToArchivedList(String taskId) {
        int index = findTask(taskId, list);
        Task completedTask = list.get(index);
        completedTask.setDone(true);
        if (list.get(index) instanceof RecurringTask) {
            archivedList.add(clone(completedTask));
            skipForMark(index);
        } else {
            archivedList.add(list.get(index));
            list.remove(index);
        }
        commandMap.get(Commands.MARK_TASK).execute(archivedList, completedTask.getId());
        manageStacks(Commands.MARK_TASK);
    }

    // requires cloning to prevent the reucrring task from changing values
    private RecurringTask clone(Task completedTask) {
        return new RecurringTask(completedTask.getName(), completedTask.getStartDate(),
                completedTask.getDueDate(), ((RecurringTask) completedTask).getRecurType(),
                completedTask.getStartTime(), completedTask.getEndTime(),
                ((RecurringTask) completedTask).getNumberToRecur());
    }

    public void changeDir(String path) {
        storage.setSavePath(path);
        saveList();
    }

    public int findTask(String id, List<Task> list) {
        final int INVALID = -1;
        int position = INVALID;
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).getId().equals(id)) {
                position = i;
            }
        }
        return position;
    }

    private void saveList() {
        storage.save(list);
    }
}
```
###### src\logic\MarkTask.java
``` java

import model.RecurringTask;
import model.Task;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

public class MarkTask<E> extends SkipRecurTask<E> implements Command<Object> {
    private static Logger loggerMark = Logger.getLogger("log");
    ArrayList<Task> archivedList;
    private Stack<Task> undoStack = new Stack<Task>();
    private Stack<Task> redoStack = new Stack<Task>();
    private Stack<String> undoStackId = new Stack<String>();
    private Stack<String> redoStackId = new Stack<String>();
    private static final int OFFSET = 1;

    @Override
    public void execute(List list, Object op) {
        loggerMark.log(Level.INFO, "Init variables for mark");
        archivedList = (ArrayList<Task>) list;
        String taskId = (String) op;
        Task archivedTask = archivedList.get(archivedList.size() - OFFSET);
        assert (archivedTask != null);
        loggerMark.log(Level.INFO, "Finish init of variables, Start the stack manipulation");
        executeArchive(taskId, archivedTask);
        loggerMark.log(Level.INFO, "End");
    }

    private void executeArchive(String taskId, Task archivedTask) {
        if (archivedTask instanceof RecurringTask) {
            undoStackId.push(taskId);
        }
        undoStack.push(archivedTask);
    }

    @Override
    // puts task back to list
    public void undo(ArrayList<Task> list) {
        assert (archivedList.size() > 0);
        loggerMark.log(Level.INFO, "Start undo process for mark");
        try {
            archivedList.remove(archivedList.size() - OFFSET);
            Task undoTask = undoStack.pop();
            if (undoTask instanceof RecurringTask) {
                undoForRecurringTask(list);
            } else {
                list.add(undoTask);
            }
            redoStack.push(undoTask);
        } catch (Exception e) {
            loggerMark.log(Level.WARNING, "Error in undo-ing for mark");
        }
        loggerMark.log(Level.INFO, "End");
    }

    // return the recurring task from archived as well as to shift the date back
    private void undoForRecurringTask(ArrayList<Task> list) {
        String taskId = undoStackId.pop();
        redoStackId.push(taskId);
        int positionOfRecurringTask = findTask(taskId, list);
        moveDateBackward((RecurringTask) list.get(positionOfRecurringTask));
    }

    @Override
    // puts task back to ARCHIVED list
    public void redo(ArrayList list) {
        loggerMark.log(Level.INFO, "Start redo process for mark");
        try {
            Task redoTask = redoStack.pop();
            undoStack.push(redoTask);
            archivedList.add(redoTask);
            if (redoTask instanceof RecurringTask) {
                redoForRecurringTask(list);
            } else {
                list.remove(findTask(redoTask.getId(), list));
            }
        } catch (Exception e) {
            loggerMark.log(Level.WARNING, "Error in redo-ing for mark");
        }
        loggerMark.log(Level.INFO, "End");
    }

    // backs the recurring task back into archived list and shift the date forward
    private void redoForRecurringTask(ArrayList list) {
        String taskId = redoStackId.pop();
        undoStackId.push(taskId);
        int positionOfRecurringTask = findTask(taskId, list);
        undoStack.push((RecurringTask) list.get(positionOfRecurringTask));
        moveDateForward((RecurringTask) list.get(positionOfRecurringTask));
    }

    @Override
    public int findTask(String id, ArrayList<Task> list) {
        final int INVALID = -1;
        int position = INVALID;
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).getId().equals(id)) {
                position = i;
            }
        }
        return position;
    }
}
```
###### src\logic\SkipRecurTask.java
``` java

import model.RecurringTask;
import model.Task;

import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

public class SkipRecurTask<E> implements Command<Object> {
    private static Logger loggerSkip = Logger.getLogger("log");
    private Stack<Integer> undoStackInt = new Stack<Integer>();
    private Stack<Integer> redoStackInt = new Stack<Integer>();
    private static final String MONTH = "month";
    private static final String DAY = "day";
    private static final String WEEK = "week";
    private static final String MONTHS = "months";
    private static final String DAYS = "days";
    private static final String WEEKS = "weeks";

    @Override
    public void execute(List<Task> list, Object index) {
        executeSkip(list, (int) index);
    }

    private void executeSkip(List<Task> list, int index) {
        loggerSkip.log(Level.INFO, "Start skipping");
        try {
            RecurringTask recurringTask = (RecurringTask) list.get(index);
            moveDateForward(recurringTask);
            Collections.sort(list);
            undoStackInt.push(findTask(recurringTask.getId(), (ArrayList<Task>) list));
        } catch (IndexOutOfBoundsException e) {
            loggerSkip.log(Level.WARNING, "Out of bound index");
            throw new IndexOutOfBoundsException();
        } catch (NumberFormatException e) {
            loggerSkip.log(Level.WARNING, "Invalid index");
            throw new NumberFormatException();
        }
        loggerSkip.log(Level.INFO, "End");
    }

    // shift the date backwards by using adjustDate methods
    protected void moveDateBackward(RecurringTask task) {
        assert (task != null);
        task.adjustDate();
        if (task.getRecurType().equalsIgnoreCase(WEEK) || task.getRecurType().equalsIgnoreCase(WEEKS)) {
            adjustDatesBackwardForWeeks(task);
        } else if (task.getRecurType().equalsIgnoreCase(DAY) || task.getRecurType().equalsIgnoreCase(DAYS)) {
            adjustDatesBackwardForDays(task);
        } else if (task.getRecurType().equalsIgnoreCase(MONTH) || task.getRecurType()
                .equalsIgnoreCase(MONTHS)) {
            adjustDatesBackwardForMonths(task);
        } else {
            adjustDatesBackwardForYears(task);
        }
    }

    // shift the dates forward using some of the adjustDate methods
    protected void moveDateForward(RecurringTask task) {
        assert (task != null);
        task.adjustDate();
        if (task.getRecurType().equalsIgnoreCase(WEEK) || task.getRecurType().equalsIgnoreCase(WEEKS)) {
            adjustDatesForwardForWeeks(task);
        } else if (task.getRecurType().equalsIgnoreCase(DAY) || task.getRecurType().equalsIgnoreCase(DAYS)) {
            adjustDatesForwardForDays(task);
        } else if (task.getRecurType().equalsIgnoreCase(MONTH) || task.getRecurType()
                .equalsIgnoreCase(MONTHS)) {
            adjustDatesForwardForMonths(task);
        } else {
            adjustDatesForwardForYears(task);
        }
    }

    private void adjustDatesForwardForWeeks(RecurringTask task) {
        if (!task.isDueDateEmpty()) {
            task.setEndDate(task.getDueDate().plusWeeks(task.getNumberToRecur()));
        }

        if (!task.isStartDateEmpty()) {
            task.setStartDate(task.getStartDate().plusWeeks(task.getNumberToRecur()));
        }
    }

    private void adjustDatesForwardForDays(RecurringTask task) {
        if (!task.isDueDateEmpty()) {
            task.setEndDate(task.getDueDate().plusDays(task.getNumberToRecur()));
        }

        if (!task.isStartDateEmpty()) {
            task.setStartDate(task.getStartDate().plusDays(task.getNumberToRecur()));
        }
    }

    private void adjustDatesForwardForMonths(RecurringTask task) {
        if (!task.isDueDateEmpty()) {
            task.setEndDate(task.getDueDate().plusMonths(task.getNumberToRecur()));
        }

        if (!task.isStartDateEmpty()) {
            task.setStartDate(task.getStartDate().plusMonths(task.getNumberToRecur()));
        }
    }

    private void adjustDatesForwardForYears(RecurringTask task) {
        if (!task.isDueDateEmpty()) {
            task.setEndDate(task.getDueDate().plusYears(task.getNumberToRecur()));
        }

        if (!task.isStartDateEmpty()) {
            task.setStartDate(task.getStartDate().plusYears(task.getNumberToRecur()));
        }
    }

    private void adjustDatesBackwardForWeeks(RecurringTask task) {
        if (!task.isDueDateEmpty()) {
            task.setEndDate(task.getDueDate().minusWeeks(task.getNumberToRecur()));
        }

        if (!task.isStartDateEmpty()) {
            task.setStartDate(task.getStartDate().minusWeeks(task.getNumberToRecur()));
        }
    }

    private void adjustDatesBackwardForDays(RecurringTask task) {
        if (!task.isDueDateEmpty()) {
            task.setEndDate(task.getDueDate().minusDays(task.getNumberToRecur()));
        }

        if (!task.isStartDateEmpty()) {
            task.setStartDate(task.getStartDate().minusDays(task.getNumberToRecur()));
        }
    }

    private void adjustDatesBackwardForMonths(RecurringTask task) {
        if (!task.isDueDateEmpty()) {
            task.setEndDate(task.getDueDate().minusMonths(task.getNumberToRecur()));
        }

        if (!task.isStartDateEmpty()) {
            task.setStartDate(task.getStartDate().minusMonths(task.getNumberToRecur()));
        }
    }

    private void adjustDatesBackwardForYears(RecurringTask task) {
        if (!task.isDueDateEmpty()) {
            task.setEndDate(task.getDueDate().minusYears(task.getNumberToRecur()));
        }

        if (!task.isStartDateEmpty()) {
            task.setStartDate(task.getStartDate().minusYears(task.getNumberToRecur()));
        }
    }

    @Override
    public void undo(ArrayList<Task> list) {
        loggerSkip.log(Level.INFO, "Start undo process for skip");
        try {
            undoSkip(list);
        } catch (EmptyStackException e) {
            loggerSkip.log(Level.WARNING, "Stack is empty");
        } catch (IndexOutOfBoundsException e) {
            loggerSkip.log(Level.WARNING, "Index is out of range");
        }
        loggerSkip.log(Level.INFO, "End");
    }

    // shifts back the date for recurring task at undo index
    private void undoSkip(ArrayList<Task> list) {
        int undoIndex = undoStackInt.pop();
        RecurringTask recurringTask = (RecurringTask) list.get(undoIndex);
        moveDateBackward((RecurringTask) list.get(undoIndex));
        Collections.sort(list);
        redoStackInt.push(findTask(recurringTask.getId(), list));
    }

    @Override
    public void redo(ArrayList<Task> list) {
        loggerSkip.log(Level.INFO, "Start redo process for skip");
        try {
            redoSkip(list);
        } catch (EmptyStackException e) {
            loggerSkip.log(Level.WARNING, "Redo stack is empty");
        } catch (IndexOutOfBoundsException e) {
            loggerSkip.log(Level.WARNING, "Index is out of range");
        }
        loggerSkip.log(Level.INFO, "End");
    }

    // shifts forward the date for the recurring task at redoIndex
    private void redoSkip(ArrayList<Task> list) {
        int redoIndex = redoStackInt.pop();
        RecurringTask recurringTask = (RecurringTask) list.get(redoIndex);
        moveDateForward(recurringTask);
        Collections.sort(list);
        undoStackInt.push(findTask(recurringTask.getId(), list));
    }

    @Override
    public int findTask(String id, ArrayList<Task> list) {
        final int INVALID = -1;
        int position = INVALID;
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).getId().equals(id)) {
                position = i;
            }
        }
        return position;
    }
}
```
###### src\logic\StopRecurTask.java
``` java

import model.RecurringTask;
import model.Task;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class StopRecurTask<E> implements Command<Object> {
    private Stack<Task> undoRecurStack = new Stack<Task>();
    private Stack<String> undoStackId = new Stack<String>();
    private Stack<Task> redoRecurStack = new Stack<Task>();
    private Stack<String> redoStackId = new Stack<String>();

    @Override
    public void execute(List<Task> list, Object index) {
        int taskIndex = (int) index;
        if (list.get(taskIndex) instanceof RecurringTask) {
            executeStopRecurring(list, taskIndex);
        }
    }

    private void executeStopRecurring(List<Task> list, int index) {
        RecurringTask recurringTask = (RecurringTask) list.get(index);
        undoRecurStack.push(recurringTask);
        Task task = recurringTask.stopRecurring();
        undoStackId.push(task.getId());
        list.set(index, task);
    }

    @Override
    public void undo(ArrayList<Task> list) {
        Task previousTask = undoStopRecurTask(list);
        list.add(previousTask);
    }

    private Task undoStopRecurTask(ArrayList<Task> list) {
        String undoTaskId = undoStackId.pop();
        Task previousTask = undoRecurStack.pop();
        Task taskToBeReomved = list.remove(findTask(undoTaskId, list));
        redoRecurStack.push(taskToBeReomved);
        redoStackId.push(undoTaskId);
        return previousTask;
    }

    @Override
    public void redo(ArrayList<Task> list) {
        Task previousTask = redoStopRecurTask(list);
        list.add(previousTask);
    }

    private Task redoStopRecurTask(ArrayList<Task> list) {
        String redoTaskId = redoStackId.pop();
        Task previousTask = redoRecurStack.pop();
        undoStackId.push(redoTaskId);
        undoRecurStack.push(list.remove(findTask(redoTaskId, list)));
        return previousTask;
    }

    private RecurringTask clone(RecurringTask recurringTask) {
        RecurringTask clone = new RecurringTask(recurringTask.getName(), recurringTask.getStartDate(),
                recurringTask.getDueDate(), recurringTask.getRecurType(), recurringTask.getStartTime(),
                recurringTask.getEndTime(), recurringTask.getNumberToRecur());
        return clone;
    }

    @Override
    public int findTask(String id, ArrayList<Task> list) {
        final int INVALID = -1;
        int position = INVALID;
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).getId().equals(id)) {
                position = i;
            }
        }
        return position;
    }

}
```
###### src\logic\UpdateTask.java
``` java

import model.RecurringTask;
import model.Task;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

public class UpdateTask<E> implements Command<Object> {
    private static Logger loggerUpdate = Logger.getLogger("log");
    private static Stack<Task> undoStackTask = new Stack<Task>();
    private static Stack<Integer> undoStackInt = new Stack<Integer>();
    private static Stack<Task> redoStackTask = new Stack<Task>();
    private static Stack<Integer> redoStackInt = new Stack<Integer>();

    @Override
    public void execute(List<Task> list, Object index) {
        loggerUpdate.log(Level.INFO, "Start updating");
        try {
            int taskIndex = (int) index;
            assert (taskIndex >= 0);
            undoStackTask.push(list.get(taskIndex));
            executeUpdate(taskIndex, list);
            loggerUpdate.log(Level.INFO, "End");
        } catch (AssertionError e) {
            loggerUpdate.log(Level.WARNING, "Cannot update negative index");
            throw new IllegalArgumentException();
        } catch (NumberFormatException e) {
            loggerUpdate.log(Level.WARNING, "Cannot update an index thats not a number");
            throw new NumberFormatException();
        }
    }

    public void executeUpdate(int taskIndex, List<Task> list) {
        final int OFFSET = 1;
        Task newTask = list.remove(list.size() - OFFSET);
        Task updatedTask = checkAttributesForTask(newTask, taskIndex, list);
        updatedTask.setTaskType();
        list.set(taskIndex, updatedTask);
        Collections.sort(list);
        undoStackInt.push(findTask(updatedTask.getId(), (ArrayList<Task>) list));
    }

    // transfer the task attributes to recurring task
    private RecurringTask transferAttributes(Task updatedTask, int index, List<Task> list) {
        RecurringTask recurringTask = new RecurringTask(updatedTask.getName(), updatedTask.getStartDate(),
                updatedTask.getDueDate(), ((RecurringTask) list.get(index)).getRecurType(),
                updatedTask.getStartTime(), updatedTask.getEndTime(),
                ((RecurringTask) list.get(index)).getNumberToRecur());
        return recurringTask;
    }

    // checks which attributes the user wishes to update and update accordingly
    private Task checkAttributesForTask(Task updatedTask, int taskIndex, List<Task> list) {
        if (updatedTask.isStartDateEmpty() && !list.get(taskIndex).isStartDateEmpty()) {
            updatedTask.setStartDate(list.get(taskIndex).getStartDate());
        }

        if (updatedTask.isDueDateEmpty() && !list.get(taskIndex).isDueDateEmpty()) {
            updatedTask.setEndDate(list.get(taskIndex).getDueDate());
        }

        if (updatedTask.getName().isEmpty() && !list.get(taskIndex).getName().isEmpty()) {
            updatedTask.setName(list.get(taskIndex).getName());
        }

        if (updatedTask.isStartTimeEmpty() && !list.get(taskIndex).isStartTimeEmpty()) {
            updatedTask.setStartTime(list.get(taskIndex).getStartTime());
        }

        if (updatedTask.isEndTimeEmpty() && !list.get(taskIndex).isEndTimeEmpty()) {
            updatedTask.setEndTime(list.get(taskIndex).getEndTime());
        }

        if (list.get(taskIndex) instanceof RecurringTask) {
            return transferAttributes(updatedTask, taskIndex, list);
        } else {
            return updatedTask;
        }
    }

    @Override
    public void undo(ArrayList<Task> list) {
        Task undoTask = undoUpdate(list);
        Collections.sort(list);
        redoStackInt.push(findTask(undoTask.getId(), list));
    }

    private Task undoUpdate(ArrayList<Task> list) {
        int undoIndex = undoStackInt.pop();
        Task undoTask = undoStackTask.pop();
        redoStackTask.push(list.get(undoIndex));
        list.set(undoIndex, undoTask);
        return undoTask;
    }

    @Override
    public void redo(ArrayList<Task> list) {
        Task redoTask = redoUpdate(list);
        Collections.sort(list);
        undoStackInt.push(findTask(redoTask.getId(), list));
    }

    private Task redoUpdate(ArrayList<Task> list) {
        int redoIndex = redoStackInt.pop();
        Task redoTask = redoStackTask.pop();
        undoStackTask.push(list.get(redoIndex));
        list.set(redoIndex, redoTask);
        return redoTask;
    }

    @Override
    public int findTask(String id, ArrayList<Task> list) {
        final int INVALID = -1;
        int position = INVALID;
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).getId().equals(id)) {
                position = i;
            }
        }
        return position;
    }
}
```
###### src\model\RecurringTask.java
``` java

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.temporal.ChronoUnit;

public class RecurringTask extends Task {
    private String recurType;
    int numberToRecur;

    public RecurringTask(String taskName, LocalDate startDate, LocalDate endDate, String recurType,
            LocalTime startTime, LocalTime endTime, int numberToRecur) {
        super(taskName, startDate, endDate, startTime, endTime);
        this.recurType = recurType;
        this.numberToRecur = numberToRecur;
    }

    public void adjustDate() {
        if (LocalDate.now().isAfter(this.getDueDate())) {
            addOffset();
        }
    }

    public String getRecurType() {
        return this.recurType;
    }

    public int getNumberToRecur() {
        return this.numberToRecur;
    }

    private void addOffset() {
        long amount = this.getDueDate().until(LocalDate.now(), ChronoUnit.DAYS);
        if (this.getRecurType().toLowerCase().equals("week") || this.getRecurType().toLowerCase()
                .equals("weeks")) {
            int offset = calculateOffsetForWeeks((int) amount, this.getNumberToRecur());
            setNextDates(this.getStartDate().plusWeeks(offset), this.getDueDate().plusWeeks(offset));
        } else if (this.getRecurType().toLowerCase().equals("day") || this.getRecurType().toLowerCase()
                .equals("days")) {
            int offset = calculateOffsetForDays((int) amount, this.getNumberToRecur());
            setNextDates(this.getStartDate().plusDays(offset), this.getDueDate().plusDays(offset));
        } else if (this.getRecurType().toLowerCase().equals("month") || this.getRecurType().toLowerCase()
                .equals("months")) {
            long amountOfMonths = this.getDueDate().until(LocalDate.now(), ChronoUnit.MONTHS);
            setNextDates(this.getStartDate().plusMonths(amountOfMonths + 1),
                    this.getDueDate().plusMonths(amountOfMonths + 1));
        } else {
            long amountOfYears = this.getDueDate().until(LocalDate.now(), ChronoUnit.YEARS);
            setNextDates(this.getStartDate().plusYears(amountOfYears + 1),
                    this.getDueDate().plusYears(amountOfYears + 1));
        }
    }

    private int calculateOffsetForWeeks(int differenceInTimes, int iteration) {
        int amount = iteration * 7;
        int numberOfWeeks = differenceInTimes;
        // System.out.println("differnece = " + differenceInTimes);
        if (differenceInTimes % amount != 0) {
            for (int i = differenceInTimes; i % amount != 0; i++) {
                //System.out.print("number of weeks = " + numberOfWeeks);
                numberOfWeeks = i;
            }
        }
        return (numberOfWeeks + 1) / 7;
    }

    private int calculateOffsetForDays(int differenceInTimes, int iteration) {
        int amount = iteration;
        int numberOfDays = differenceInTimes;
        if (differenceInTimes % amount != 0) {
            for (int i = differenceInTimes; i % amount != 0; i++) {
                numberOfDays = i;
            }
            numberOfDays++;
        }
        return (numberOfDays);
    }

    private void setNextDates(LocalDate startDate, LocalDate endDate) {
        setStartDate(startDate);
        setEndDate(endDate);
    }

    public Task stopRecurring() {
        Task newTask = new Task(this.getName(), this.getStartDate(), this.getDueDate(), this.getStartTime(),
                this.getEndTime());
        return newTask;
    }
}
```
###### src\model\Task.java
``` java
    @Override
    public int compareTo(Object task) {
        Task comparedTask = (Task) task;
        int result = compareDueDate(comparedTask, this);

        if (result == 0) {
            result = compareStartDate(comparedTask, this);
        }

        if (result == 0) {
            result = comparedTask.getName().compareTo(this.getName());
        }
        return result;
    }

    private int compareDueDate(Task task, Task comparedTask) {
        if (task.isDueDateEmpty() && comparedTask.isDueDateEmpty()) {
            System.out.println(task.getName() + " due is empty");
            return 0;
        } else if (!task.isDueDateEmpty() && comparedTask.isDueDateEmpty()) {
            return 1;
        } else if (task.isDueDateEmpty() && !comparedTask.isDueDateEmpty()) {
            return -1;
        } else {
            return comparedTask.getDueDate().compareTo(task.getDueDate());
        }
    }

    private int compareStartDate(Task task, Task comparedTask) {
        if (task.isStartDateEmpty() && comparedTask.isStartDateEmpty()) {
            System.out.println(task.getName() + " add Start is empty");
            return 0;
        } else if (!task.isStartDateEmpty() && comparedTask.isStartDateEmpty()) {
            return 1;
        } else if (task.isStartDateEmpty() && !comparedTask.isStartDateEmpty()) {
            return -1;
        } else {
            return task.getStartDate().compareTo(comparedTask.getStartDate());
        }
    }

    public boolean isDueDateEmpty() {
        return this.getDueDate() == null || this.getDueDate().equals(LocalDate.MIN) || this.getDueDate()
                .equals(LocalDate.MAX);
    }

    public boolean isStartDateEmpty() {
        return this.getStartDate() == null || this.getStartDate().equals(LocalDate.MIN) || this.getStartDate()
                .equals(LocalDate.MAX);
    }

    public boolean isStartTimeEmpty() {
        return this.getStartTime() == null || this.getStartTime().equals(LocalTime.MAX) || this.getStartTime()
                .equals(LocalTime.MIN);
    }

    public boolean isEndTimeEmpty() {
        return this.getEndTime() == null || this.getEndTime().equals(LocalTime.MAX) || this.getEndTime()
                .equals(LocalTime.MIN);
    }

    public boolean isDatesInvalid() {
        return this.getStartDate().isAfter(this.getDueDate());
    }
}
```
###### src\parser\DaysInWeek.java
``` java



import java.time.LocalDate;

public class DaysInWeek {
    private static LocalDate monday;
    private static LocalDate tuesday;
    private static LocalDate wednesday;
    private static LocalDate thursday;
    private static LocalDate friday;
    private static LocalDate saturday;
    private static LocalDate sunday;

    public DaysInWeek() {
        switch (LocalDate.now().getDayOfWeek()) {
            case MONDAY:
                setMonday();
                break;
            case TUESDAY:
                setTuesday();
                break;
            case WEDNESDAY:
                setWednesday();
                break;
            case THURSDAY:
                setThursday();
                break;
            case FRIDAY:
                setFriday();
                break;
            case SATURDAY:
                setSaturday();
                break;
            default:
                setSunday();
                break;
        }
    }

    private void setMonday() {
        monday = LocalDate.now();
        tuesday = LocalDate.now().plusDays(1);
        wednesday = LocalDate.now().plusDays(2);
        thursday = LocalDate.now().plusDays(3);
        friday = LocalDate.now().plusDays(4);
        saturday = LocalDate.now().plusDays(5);
        sunday = LocalDate.now().plusDays(6);
    }

    private void setTuesday() {
        tuesday = LocalDate.now();
        wednesday = LocalDate.now().plusDays(1);
        thursday = LocalDate.now().plusDays(2);
        friday = LocalDate.now().plusDays(3);
        saturday = LocalDate.now().plusDays(4);
        sunday = LocalDate.now().plusDays(5);
        monday = LocalDate.now().plusDays(6);
    }

    private void setWednesday() {
        wednesday = LocalDate.now();
        thursday = LocalDate.now().plusDays(1);
        friday = LocalDate.now().plusDays(2);
        saturday = LocalDate.now().plusDays(3);
        sunday = LocalDate.now().plusDays(4);
        monday = LocalDate.now().plusDays(5);
        tuesday = LocalDate.now().plusDays(6);
    }

    private void setThursday() {
        thursday = LocalDate.now();
        friday = LocalDate.now().plusDays(1);
        saturday = LocalDate.now().plusDays(2);
        sunday = LocalDate.now().plusDays(3);
        monday = LocalDate.now().plusDays(4);
        tuesday = LocalDate.now().plusDays(5);
        wednesday = LocalDate.now().plusDays(6);
    }

    private void setFriday() {
        friday = LocalDate.now();
        saturday = LocalDate.now().plusDays(1);
        sunday = LocalDate.now().plusDays(2);
        monday = LocalDate.now().plusDays(3);
        tuesday = LocalDate.now().plusDays(4);
        wednesday = LocalDate.now().plusDays(5);
        thursday = LocalDate.now().plusDays(6);
    }

    private void setSaturday() {
        saturday = LocalDate.now();
        sunday = LocalDate.now().plusDays(1);
        monday = LocalDate.now().plusDays(2);
        tuesday = LocalDate.now().plusDays(3);
        wednesday = LocalDate.now().plusDays(4);
        thursday = LocalDate.now().plusDays(5);
        friday = LocalDate.now().plusDays(6);
    }

    private void setSunday() {
        sunday = LocalDate.now();
        monday = LocalDate.now().plusDays(1);
        tuesday = LocalDate.now().plusDays(2);
        wednesday = LocalDate.now().plusDays(3);
        thursday = LocalDate.now().plusDays(4);
        friday = LocalDate.now().plusDays(5);
        saturday = LocalDate.now().plusDays(6);
    }

    public LocalDate getMonday() {
        return this.monday;
    }

    public LocalDate getTuesday() {
        return this.tuesday;
    }

    public LocalDate getWednesday() {
        return this.wednesday;
    }

    public LocalDate getThursday() {
        return this.thursday;
    }

    public LocalDate getFriday() {
        return this.friday;
    }

    public LocalDate getSaturday() {
        return this.saturday;
    }

    public LocalDate getSunday() {
        return this.sunday;
    }
}
```
###### src\ui\controller\MainWindowController.java
``` java
    private static final String MESSAGE_FOR_CLEARING = "All tasks are removed from QuickTasker.";
    private static final String MESSAGE_FOR_STOPPING_RECUR = "index %d is not recurring now";
    private static final String MESSAGE_FOR_UNDO = "Undone last operation. Yay!";
    private static final String MESSAGE_FOR_REDO = "Redo the last undo. Yay!";
    private static final String MESSAGE_FOR_CLASHING_TIME_SLOTS = "WARNING: YOU HAVE CLASHING TIME SLOTS";
    private static final String ERROR_MESSAGE_FOR_WRONG_INDEX = "The index you entered is invalid!";
    private static final String ERROR_MESSAGE_FOR_INVALID_INDEX = "This index is not a number!";
    private static final String ERROR_MESSAGE_FOR_NOT_RECURRING_TASK = "This index is not a recurring task!";
    private static final String ERROR_MESSAGE_FOR_NO_TASK_ENTERED = "Did you enter a recurring task?";
    private static final String ERROR_MESSAGE_FOR_EMPTY_TASK = "Did you enter a task correctly?";
    private static final String ERROR_MESSAGE_FOR_REDO_ERROR = "Did you undo before this?";
    private static final String ERROR_MESSAGE_FOR_UNDO_ERROR = "No operations to undo before this.";

    private static final String ERROR_MESSAGE_FOR_INVALID_INPUT = "Invalid Input. Please retype.";
    private static final int OFFSET = 1;
    
    public MainWindowController() {}

    public static Logger getLogger() {
        return logger;
    }

    @Override
    public void initialize(URL location, ResourceBundle b) {
        initLogger();
        initPlanner();
        setCellFactory();
    }

```
###### src\ui\controller\MainWindowController.java
``` java
    void showMonday() {
        printedPlanner.setItems(plannerEntries.filtered(task -> search.isTaskDueOnMonday(task)));
        headerTitle.setText("Tasks: Monday");
        setUpDisplay();
    }

    void showTuesday() {
        printedPlanner.setItems(plannerEntries.filtered(task -> search.isTaskDueOnTuesday(task)));
        headerTitle.setText("Tasks: Tuesday");
        setUpDisplay();
    }

    void showWednesday() {
        printedPlanner.setItems(plannerEntries.filtered(task -> search.isTaskDueOnWednesday(task)));
        headerTitle.setText("Tasks: Wednesday");
        setUpDisplay();
    }

    void showThursday() {
        printedPlanner.setItems(plannerEntries.filtered(task -> search.isTaskDueOnThursday(task)));
        headerTitle.setText("Tasks: Thursday");
        setUpDisplay();
    }

    void showFriday() {
        printedPlanner.setItems(plannerEntries.filtered(task -> search.isTaskDueOnFriday(task)));
        headerTitle.setText("Tasks: Friday");
        setUpDisplay();
    }

    void showSaturday() {
        printedPlanner.setItems(plannerEntries.filtered(task -> search.isTaskDueOnSaturday(task)));
        headerTitle.setText("Tasks: Saturday");
        setUpDisplay();
    }

    void showSunday() {
        printedPlanner.setItems(plannerEntries.filtered(task -> search.isTaskDueOnSunday(task)));
        headerTitle.setText("Tasks: Sunday");
        setUpDisplay();
    }

```
###### src\ui\controller\MainWindowController.java
``` java
    void markTaskCompleted(String userInput) throws Exception {
        try {
            int i = parser.getIndexForDone(userInput);
            Task task = plannerEntries.get(i);
            printedPlanner.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
            printedPlanner.getSelectionModel().select(i);
            printedPlanner.fireEvent(new TaskDoneEvent(task));
        } catch (NumberFormatException e) {
            displayMessage(ERROR_MESSAGE_FOR_WRONG_INDEX);
        } catch (IndexOutOfBoundsException e) {
            displayMessage(ERROR_MESSAGE_FOR_INVALID_INDEX);
        }
    }

```
###### src\ui\controller\MainWindowController.java
``` java
    void viewArchived() {
        plannerEntries = FXCollections.observableArrayList(operations.getArchivedTasks());
        afterOperation();
        headerTitle.setText("Tasks: Archived");
        setArchivedIcon();
    }

    void clearTasks() {
        plannerEntries = FXCollections.observableArrayList(operations.clear());
        afterOperation();
        displayMessage(MESSAGE_FOR_CLEARING);
    }

    //Skip 1 iteration for that recurring task in that index
    void skipRecurringTask(String userInput) throws Exception {
        try {
            skipRecurringTaskOperation(userInput);
            afterOperation();
        } catch (IndexOutOfBoundsException e) {
            displayMessage(ERROR_MESSAGE_FOR_WRONG_INDEX);
        } catch (NumberFormatException e) {
            displayMessage(ERROR_MESSAGE_FOR_INVALID_INDEX);
        }
    }
    private void skipRecurringTaskOperation(String userInput) {
        int index = parser.getTaskIndex(userInput);
        if (!(plannerEntries.get(index) instanceof RecurringTask))
            displayMessage(ERROR_MESSAGE_FOR_NOT_RECURRING_TASK);
        else {
            plannerEntries = FXCollections.observableArrayList(operations.skip(index));
            displayMessage(MESSAGE_FOR_DATE_CHANGE);
        }
    }
    void stopRecurringTask(String userInput) throws Exception {
        int taskIndex = parser.getTaskIndex(userInput);
        if (plannerEntries.get(taskIndex) instanceof RecurringTask) {
            plannerEntries = FXCollections.observableArrayList(operations.stopRecurring(taskIndex));
            displayMessage(String.format(MESSAGE_FOR_STOPPING_RECUR, taskIndex + OFFSET));
        } else {
            displayMessage(ERROR_MESSAGE_FOR_NOT_RECURRING_TASK);
        }
        afterOperation();
    }
    void redoTask() {
        try {
            plannerEntries = FXCollections.observableArrayList(operations.redo());
            displayMessage(MESSAGE_FOR_REDO);
            afterOperation();
        } catch (EmptyStackException e) {
            displayMessage(ERROR_MESSAGE_FOR_REDO_ERROR);
        }
    }
    void undoTask() {
        try {
            plannerEntries = FXCollections.observableArrayList(operations.undo());
            displayMessage(MESSAGE_FOR_UNDO);
            afterOperation();
        } catch (EmptyStackException e) {
            displayMessage(ERROR_MESSAGE_FOR_UNDO_ERROR);
        }
    }
    void updateTask(String userInput) throws Exception {
        try {
            updateTaskOperation(userInput);
            afterOperation();
            displayMessage(MESSAGE_EDIT_CONFIRMED);
        } catch (IndexOutOfBoundsException e) {
            displayMessage(ERROR_MESSAGE_FOR_WRONG_INDEX);
        } catch (NumberFormatException e) {
            displayMessage(ERROR_MESSAGE_FOR_INVALID_INDEX);
        }
    }
    private void updateTaskOperation(String userInput) {
        int indexOfTask = updateParser.getTaskIndex(userInput);
        printedPlanner.getSelectionModel().select(indexOfTask);
        Task newTask = makeTaskForUpdate(userInput);
        plannerEntries = FXCollections.observableArrayList(operations.updateTask(newTask, indexOfTask));
        printedPlanner.getSelectionModel().clearSelection();
    }
    void deleteTask(String userInput) throws Exception {
        try {
            deleteTaskOperation(userInput);
            afterOperation();
            displayMessage(MESSAGE_DELETE_CONFIRMED);
        } catch (NumberFormatException e) {
            displayMessage(ERROR_MESSAGE_FOR_INVALID_INDEX);
        } catch (IllegalArgumentException e) {
            displayMessage(ERROR_MESSAGE_FOR_WRONG_INDEX);
        } catch (IndexOutOfBoundsException e) {
            displayMessage(ERROR_MESSAGE_FOR_WRONG_INDEX);
        }
    }
    private void deleteTaskOperation(String userInput) {
        plannerEntries = FXCollections
                .observableArrayList(operations.deleteTask(parser.getTaskIndex(userInput)));
    }

```
###### src\ui\controller\MainWindowController.java
``` java
    void addTask(String userInput) throws Exception {
        try {
            addTaskOperation(userInput);
            afterOperation();
            displayMessage(MESSAGE_ADD_CONFIRMED);
            printedPlanner.scrollTo(printedPlanner.getItems().size() - 1);
        } catch (IndexOutOfBoundsException e) {
            displayMessage(ERROR_MESSAGE_FOR_EMPTY_TASK);
        }
    }
    private void addTaskOperation(String userInput) throws Exception {
        Task newTask = makeTask(userInput);
        //if (isTimeSlotClashing(newTask)) displayMessage(MESSAGE_FOR_CLASHING_TIME_SLOTS);
        plannerEntries = FXCollections.observableArrayList(operations.addTask(newTask));
    }
    void addRecurringTask(String userInput) throws Exception {
        try {
            addRecurringTaskOperation(userInput);
            afterOperation();
            displayMessage(MESSAGE_ADD_CONFIRMED);
        } catch (IndexOutOfBoundsException e) {
            displayMessage(ERROR_MESSAGE_FOR_NO_TASK_ENTERED);
        } catch (NumberFormatException e) {
            displayMessage(ERROR_MESSAGE_FOR_NO_TASK_ENTERED);
        } catch (NullPointerException e) {
            displayMessage(ERROR_MESSAGE_FOR_EMPTY_TASK);
        }
    }
    private void addRecurringTaskOperation(String userInput) throws Exception {
        RecurringTask newTask = makeRecurringTask(userInput);
        plannerEntries = FXCollections.observableArrayList(operations.addTask(newTask));
    }
    //Clear the command box and set up new list for view
    private void afterOperation() {
        setCellFactory();
        refresh();
        updateTaskCounter();
        commandBox.clear();
    }

    private Task makeTask(String userInput) throws Exception {
        return new Task(parser.getTaskName(userInput), parser.getStartDate(userInput),
                parser.getEndDate(userInput), parser.getStartTime(userInput), parser.getEndTime(userInput));
    }
    private RecurringTask makeRecurringTask(String userInput) throws Exception {
        return new RecurringTask(recurringParser.getTaskName(userInput),
                recurringParser.getTaskStartDate(userInput), recurringParser.getTaskEndDate(userInput),
                recurringParser.getRecurDuration(userInput), recurringParser.getTaskStartTime(userInput),
                recurringParser.getTaskEndTime(userInput), recurringParser.getNumToRecur(userInput));
    }
    private Task makeTaskForUpdate(String userInput) {
        return new Task(updateParser.getTaskName(userInput), updateParser.getStartDate(userInput),
                updateParser.getEndDate(userInput), updateParser.getStartTime(userInput),
                updateParser.getEndTime(userInput));
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    public boolean isTaskDueOnMonday(Task task) {
        return isDueMonday(task);
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    public boolean isTaskDueOnTuesday(Task task) {
        return isDueTuesday(task);
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    public boolean isTaskDueOnWednesday(Task task) {
        return isDueWednesday(task);
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    public boolean isTaskDueOnThursday(Task task) {
        return isDueThursday(task);
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    public boolean isTaskDueOnFriday(Task task) {
        return isDueFriday(task);
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    public boolean isTaskDueOnSaturday(Task task) {
        return isDueSaturday(task);
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    public boolean isTaskDueOnSunday(Task task) {
        return isDueSunday(task);
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    private boolean isDueMonday(Task task) {
        return task.getDueDate().isEqual(getDays.getMonday());
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    private boolean isDueTuesday(Task task) {
        return task.getDueDate().isEqual(getDays.getTuesday());
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    private boolean isDueWednesday(Task task) {
        return task.getDueDate().isEqual(getDays.getWednesday());
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    private boolean isDueThursday(Task task) {
        return task.getDueDate().isEqual(getDays.getThursday());
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    private boolean isDueFriday(Task task) {
        return task.getDueDate().isEqual(getDays.getFriday());
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    private boolean isDueSaturday(Task task) {
        return task.getDueDate().isEqual(getDays.getSaturday());
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    private boolean isDueSunday(Task task) {
        return task.getDueDate().isEqual(getDays.getSunday());
    }
}
```
###### tests\logic\AddTaskTest.java
``` java

public class AddTaskTest {
    Logic logic;
    private SettingManager settings;

    @Before
    public void setUp() throws Exception {
        logic = new Logic();
        logic.clear();
        createEmptyTasks(2);
    }

    private void createEmptyTasks(int n) {
        for (int i = 0; i < n; i++) {
            logic.addTask(new Task());
        }
    }

    @Test
    public void testSizeOfListAfterAdd() throws Exception {
        assertEquals(logic.getSize(), 2);
    }

    @Test
    public void testAddNull() throws Exception {
        boolean testResult = false;
        try {
            logic.addTask(null);
        } catch (NullArgumentException e) {
            System.out.println("error is " + e);
            testResult = true;
        }
        assert (testResult);
    }

    @Test
    public void testSizeOfListAfterAddingNull() throws Exception {
        logic.addTask(new Task(null, null, null));
        assertEquals(logic.getSize(), 3);
    }

    @Test
    // A user could have added normally
    public void testNameAfterAdding() throws Exception {
        logic.addTask(new Task("name", LocalDate.now(), LocalDate.now()));
        System.out.println(logic.getSize());
        assertEquals(logic.getTasks().get(0).getName(), "name");
    }

    @Test
    // A user could have added task without start date
    public void testNameAfterAddingWithoutStartDate() throws Exception {
        logic.addTask(new Task("name", null, LocalDate.now()));
        assertEquals(logic.getTasks().get(0).getName(), "name");
    }

    @Test
    // A user could have added task without due date
    public void testNameAfterAddingWithoutDueDate() throws Exception {
        logic.addTask(new Task("name", LocalDate.now(), null));
        assertEquals(logic.getTasks().get(0).getName(), "name");
    }

    @Test
    // A user could have added task without dates
    public void testNameAfterAddingWithoutDates() throws Exception {
        logic.addTask(new Task("name", null, null));
        assertEquals(logic.getTasks().get(2).getName(), "name");
    }

    @Test
    // A user could have undo add
    public void testUndoAfterAdding() throws Exception {
        logic.commandMap.get(Commands.CREATE_TASK).undo((ArrayList<Task>) logic.list);
        assertEquals(logic.getSize(), 1);
    }
}
```
###### tests\logic\DeleteTaskTest.java
``` java

public class DeleteTaskTest {
    Logic logic;
    SettingManager settings;

    @Before
    public void setUp() throws Exception {
        init();
    }

    private void init() {
        logic = new Logic();
        logic.clear();
        for (int i = 0; i < 10; i++) {
            Task task = new Task();
            logic.list.add(task);
        }
    }

    @Test
    public void test() throws Exception {
        assertEquals(10, logic.getSize());
        logic.deleteTask(0);
        assertEquals(9, logic.getSize());
        logic.deleteTask(8);
        assertEquals(8, logic.getSize());
        logic.commandMap.get(Commands.DELETE_TASK).undo((ArrayList<Task>) logic.list);
        assertEquals(9, logic.getSize());
    }

    @Test
    public void testNegative() throws Exception {
        boolean testNegative = false;
        try {
            logic.deleteTask(-1);
        } catch (IllegalArgumentException e) {
            testNegative = true;
        }
        assert (testNegative);
    }

    @Test
    public void testString() throws Exception {
        boolean testString = false;
        try {
            logic.deleteTask(Integer.parseInt("hi"));
        } catch (NumberFormatException e) {
            testString = true;
        }
        assert (testString);
    }
}
```
###### tests\logic\SkipRecurTaskTest.java
``` java
import model.RecurringTask;
import org.junit.Before;
import org.junit.Test;

import java.time.LocalDate;

import static org.junit.Assert.assertEquals;

public class SkipRecurTaskTest {
    Logic logic;

    @Before
    public void setUp() throws Exception {
        logic = new Logic();
        logic.clear();
        createRecurringTasks(3);
    }

    private void createRecurringTasks(int n) {
        for (int i = 0; i < n; i++) {
            logic.addTask(new RecurringTask("Recurring " + i, LocalDate.now().plusDays(i),
                    LocalDate.now().plusDays(i), "weeks", null, null, 2));
        }
    }

    @Test
    public void testSizeOfListAfterAdd() throws Exception {
        assertEquals(logic.getSize(), 3);
    }

    @Test
    public void testSkip() {
        logic.skip(0);
        assertEquals("Recurring 2", logic.getTasks().get(0).getName());
        assertEquals(LocalDate.now().plusDays(2).plusWeeks(2), logic.getTasks().get(0).getStartDate());
    }

    @Test
    public void testSkipNegativeNumber() {
        boolean testNegative = false;
        try {
            logic.skip(-1);
        } catch (IndexOutOfBoundsException e) {
            testNegative = true;
        }
        assert (testNegative);
    }

    @Test
    public void testSkipOverBound() {
        boolean testOutOfBound = false;
        try {
            logic.skip(5);
        } catch (IndexOutOfBoundsException e) {
            testOutOfBound = true;
        }
        assert (testOutOfBound);
    }

    @Test
    public void testSkipNonNumberIndex() {
        boolean testNonNumberIndex = false;
        try {
            logic.skip(Integer.parseInt("hi"));
        } catch (NumberFormatException e) {
            testNonNumberIndex = true;
        }
        assert (testNonNumberIndex);
    }
}
```
###### tests\logic\UpdateTaskTest.java
``` java

import data.SettingManager;
import model.Task;
import org.junit.Before;
import org.junit.Test;

import java.time.LocalDate;

import static org.junit.Assert.assertEquals;

public class UpdateTaskTest {
    Logic logic;
    SettingManager settings;

    @Before
    public void setUp() throws Exception {
        init();
    }

    private void init() {
        logic = new Logic();
        logic.clear();
        logic.addTask(new Task("hello", LocalDate.now(), LocalDate.now()));
        logic.addTask(new Task());
    }

    @Test
    // This is the regular update
    public void testUpdatingWithName() throws Exception {
        logic.updateTask(new Task("name", LocalDate.now(), LocalDate.now()), 0);
        assertEquals("name", logic.getTasks().get(0).getName());
    }

    @Test
    // A user could have updated a longer name
    public void testUpdatingWithLongerName() throws Exception {
        logic.updateTask(new Task("name longer by alot", LocalDate.now(), LocalDate.now()), 1);
        assertEquals("name longer by alot", logic.getTasks().get(1).getName());
    }

    @Test
    // A user could have changed the task to floating 
    public void testUpdatingWithFloating() throws Exception {
        logic.updateTask(new Task("name longer by alot", null, null), 1);
        assertEquals("name longer by alot", logic.getTasks().get(0).getName());
    }

    @Test
    public void testUpdatingOnlyWithName() throws Exception {
        logic.updateTask(new Task("name longer by alot", LocalDate.MIN, LocalDate.MIN), 0);
        assertEquals("name longer by alot", logic.getTasks().get(0).getName());
        assertEquals(LocalDate.now(), logic.getTasks().get(0).getStartDate());
        assertEquals(LocalDate.now(), logic.getTasks().get(0).getDueDate());
    }

    @Test
    public void testUpdatingOnlyWithDates() throws Exception {
        logic.updateTask(new Task("", LocalDate.of(2016, 4, 1), LocalDate.of(2016, 5, 1)), 0);
        assertEquals("hello", logic.getTasks().get(0).getName());
        assertEquals(LocalDate.of(2016, 4, 1), logic.getTasks().get(0).getStartDate());
        assertEquals(LocalDate.of(2016, 5, 1), logic.getTasks().get(0).getDueDate());
    }

    @Test
    // A user could have changed name without start date
    public void testUpdatingWithoutStartDate() throws Exception {
        logic.updateTask(new Task("name longer by alot", null, LocalDate.now()), 1);
        assertEquals("name longer by alot", logic.getTasks().get(0).getName());
    }

    @Test
    // A user could have changed name without due date
    public void testUpdatingWithoutDueDate() throws Exception {
        logic.updateTask(new Task("name longer by alot", LocalDate.now(), null), 1);
        assertEquals("name longer by alot", logic.getTasks().get(0).getName());
    }

    @Test
    public void testUpdatingNegativeIndex() throws Exception {
        boolean testNegative = false;
        try {
            logic.updateTask(new Task("name longer by alot", LocalDate.now(), null), -1);
        } catch (IllegalArgumentException e) {
            testNegative = true;
        }
        assert (testNegative);
    }

    @Test
    public void testUpdatingWithString() throws Exception {
        boolean testString = false;
        try {
            logic.updateTask(new Task("name longer by alot", LocalDate.now(), null), Integer.parseInt("hi"));
        } catch (NumberFormatException e) {
            testString = true;
        }
        assert (testString);
    }
}
```
###### tests\model\RecurringTaskTest.java
``` java
import org.junit.Before;
import org.junit.Test;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

public class RecurringTaskTest {

    @Before
    public void setUp() throws Exception {
        ArrayList<Task> list = new ArrayList<Task>();
        RecurringTask task = new RecurringTask("name", LocalDate.now(), LocalDate.now(), "week",
                LocalTime.now(), LocalTime.now(), 1);
        RecurringTask taskk = new RecurringTask("name", LocalDate.now(), LocalDate.now(), "week",
                LocalTime.now(), LocalTime.now(), 1);
        list.add(task);
        list.add(taskk);
    }

    @Test
    public void test() {
        ArrayList<Task> list = new ArrayList<Task>();
        RecurringTask task = new RecurringTask("name", LocalDate.now(), LocalDate.now(), "week",
                LocalTime.now(), LocalTime.now(), 1);
        RecurringTask taskk = new RecurringTask("name", LocalDate.now(), LocalDate.now(), "week",
                LocalTime.now(), LocalTime.now(), 1);
        list.add(task);
        list.add(taskk);
        assertEquals("name", list.get(0).getName());
        assertEquals(LocalDate.now(), list.get(1).getStartDate());
        assertEquals(LocalDate.now(), list.get(1).getDueDate());
        RecurringTask taskkk = new RecurringTask("name2", LocalDate.of(2016, 03, 13),
                LocalDate.of(2016, 03, 15), "day", LocalTime.now(), LocalTime.now(), 1);
        taskkk.adjustDate();
        assertEquals(25, taskkk.getStartDate().getDayOfMonth());
        assertEquals(27, taskkk.getDueDate().getDayOfMonth());
        RecurringTask taskkkk = new RecurringTask("name2", LocalDate.of(2016, 03, 13),
                LocalDate.of(2016, 03, 15), "week", LocalTime.now(), LocalTime.now(), 1);
        taskkkk.adjustDate();
        assertEquals(27, taskkkk.getStartDate().getDayOfMonth());
        assertEquals(29, taskkkk.getDueDate().getDayOfMonth());
        RecurringTask taskkkkk = new RecurringTask("name2", LocalDate.of(2016, 03, 25),
                LocalDate.of(2016, 03, 25), "day", LocalTime.now(), LocalTime.now(), 1);
        taskkkkk.adjustDate();
        assertEquals(25, taskkkkk.getStartDate().getDayOfMonth());
        assertEquals(25, taskkkkk.getDueDate().getDayOfMonth());
        RecurringTask taskkkkkk = new RecurringTask("name2", LocalDate.of(2016, 03, 23),
                LocalDate.of(2016, 03, 24), "day", LocalTime.now(), LocalTime.now(), 1);
        taskkkkkk.adjustDate();
        assertEquals(25, taskkkkkk.getStartDate().getDayOfMonth());
        assertEquals(26, taskkkkkk.getDueDate().getDayOfMonth());
        RecurringTask taskkkkkkk = new RecurringTask("name2", LocalDate.of(2016, 03, 23),
                LocalDate.of(2016, 03, 24), "week", LocalTime.now(), LocalTime.now(), 1);
        taskkkkkkk.adjustDate();
        assertEquals(30, taskkkkkkk.getStartDate().getDayOfMonth());
        assertEquals(31, taskkkkkkk.getDueDate().getDayOfMonth());
        RecurringTask taskkkkkkkk = new RecurringTask("name2", LocalDate.of(2016, 03, 25),
                LocalDate.of(2016, 03, 25), "week", LocalTime.now(), LocalTime.now(), 1);
        taskkkkkkkk.adjustDate();
        assertEquals(25, taskkkkkkkk.getStartDate().getDayOfMonth());
        assertEquals(25, taskkkkkkkk.getDueDate().getDayOfMonth());
    }

}
```
