# A0121558H
###### QuickTasker\src\common\InvalidStringException.java
``` java
public class InvalidStringException extends Throwable {

}
```
###### QuickTasker\src\model\Task.java
``` java

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.UUID;

public class Task implements Comparable {
    private String taskName;
    private LocalDate startDate;
    private LocalDate endDate;
    private LocalTime startTime;
    private LocalTime endTime;
    private boolean isDone = false;
    private String id;
    private String taskType;

    public void setStartDateAsNow() {
        startDate = LocalDate.now();
    }

    public Task() {
        this.taskName = "";
        this.endDate = LocalDate.MIN;
        this.setStartDateAsNow();
        this.id = generateId();
        setTaskType();
    }

    /**
     * Constructor for tasks with only task name.
     */
    public Task(String taskName) {
        this.taskName = taskName;
        setStartDateAsNow();
        this.endDate = LocalDate.MIN;
        this.id = generateId();
    }

    /**
     * Constructor for floating tasks *.
     */
    public Task(String taskName, LocalDate startDate) {
        this.taskName = taskName;
        this.endDate = LocalDate.MIN;
        this.startDate = startDate;
        this.id = generateId();

    }

    /**
     * Constructor with all fields filled *.
     */
    public Task(String taskName, LocalDate startDate, LocalDate endDate) {
        this.taskName = taskName;
        this.endDate = endDate;
        this.startDate = startDate;
        this.id = generateId();
    }

    public Task(String taskName, LocalDate startDate, LocalDate endDate, LocalTime startTime,
            LocalTime endTime) {
        this.taskName = taskName;
        this.endDate = endDate;
        this.startDate = startDate;
        this.startTime = startTime;
        this.endTime = endTime;
        setTaskType();
        this.id = generateId();
    }

    public void setTaskType() {
        this.taskType = bothDateAndTimeAreDefaultValue() ?
                "floating" :
                !onlyTimeAreDefaultValue() ? "task" : "wholeDayEvent";
    }

    private boolean onlyTimeAreDefaultValue() {
        return (startTime == null || this.startTime == LocalTime.MIN) && (this.endTime == null
                || this.endTime == LocalTime.MAX);
    }

    
    private boolean bothDateAndTimeAreDefaultValue() {
        return (startDate == null || this.startDate.equals(LocalDate.MIN)) && (endDate == null || this.endDate
                .equals(LocalDate.MAX)) && (startTime == null || this.startTime.equals(LocalTime.MIN)) && (
                endDate == null || this.endDate.equals(LocalDate.MAX));
    }

    public String getTaskType() {
        return this.taskType;
    }

    public String getName() {
        return taskName;
    }

    public LocalDate getDueDate() {
        return endDate;
    }

    public LocalDate getStartDate() {
        return startDate;
    }

    public LocalTime getStartTime() {
        return startTime;
    }
```
###### QuickTasker\src\parser\Commands.java
``` java

public enum Commands {
    CREATE_TASK,
    UPDATE_TASK,
    DISPLAY_TASK,
    UNDO_TASK,
    DELETE_TASK,
    SEARCH_TASK,
    RECUR_TASK,
    SORT_TASK,
    EXIT,
    ERROR,
    REDO_TASK,
    COMPLETE_TASK,
    MARK_TASK,
    SKIP_TASK,
    STOP_TASK,
    CHANGE_DIRECTORY,
    CLEAR_TASK,
    THEME,
    HELP,
    BACK;

}
```
###### QuickTasker\src\parser\DateTimeParser.java
``` java

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;

public class DateTimeParser {
    private static DaysInWeek daysInWeek = new DaysInWeek();
    private static Logger loggerParseDate = Logger.getLogger("parseDate in DateTimeParser");
    private static Logger loggerParseTime = Logger.getLogger("parseTime in DateTimeParser");
    private static Logger loggerIsDate = Logger.getLogger("isDate in DateTimeParser");

    public LocalDate parseDate(String input) {
        loggerParseDate.log(Level.INFO, "Start of parse date");

        DateTimeFormatter formatterForDashes = DateTimeFormatter.ofPattern("dd-MM-yyyy");
        DateTimeFormatter formatterForSlashes = DateTimeFormatter.ofPattern("dd/MM/yyyy");
        DateTimeFormatter formatterEmpty = DateTimeFormatter.ofPattern("ddMMyyyy");
        DateTimeFormatter formatterDashesShortened = DateTimeFormatter.ofPattern("dd-MM-yy");
        DateTimeFormatter formatterSlashesShortened = DateTimeFormatter.ofPattern("dd/MM/yy");
        DateTimeFormatter formatterEmptyShortened = DateTimeFormatter.ofPattern("ddMMyy");

        LocalDate output;

        if (!isEnglish(input)) {
            try {
                output = LocalDate.parse(input, formatterForDashes);
                return output;
            } catch (Exception e) {
                loggerParseDate.log(Level.INFO, "Not dates  with dashes");
            }
            try {
                output = LocalDate.parse(input, formatterForSlashes);
                return output;
            } catch (Exception e) {
                loggerParseDate.log(Level.INFO, "Not date with slashes");
            }
            try {
                output = LocalDate.parse(input, formatterDashesShortened);
                return output;
            } catch (Exception e) {
                loggerParseDate.log(Level.INFO, "Not shortened date with dashes");
            }
            try {
                output = LocalDate.parse(input, formatterSlashesShortened);
                return output;
            } catch (Exception e) {
                loggerParseDate.log(Level.INFO, "Not shortened date with slashes");
            }
            try {
                output = LocalDate.parse(input, formatterEmptyShortened);
                return output;
            } catch (Exception e) {
                loggerParseDate.log(Level.INFO, "Not shortened date");
            }
            try {
                output = LocalDate.parse(input, formatterEmpty);
                return output;
            } catch (Exception e) {
                loggerParseDate.log(Level.WARNING, "Error in parsing date", e);
                output = null;
            }
        } else {
            // It is a date represented in English
            if (input.equalsIgnoreCase("today")) {
                output = LocalDate.now();
            } else if (input.equalsIgnoreCase("tomorrow")) {
                output = LocalDate.now().plusDays(1);
            } else if (input.equalsIgnoreCase("next day")) {
                output = LocalDate.now().plusDays(1);
            } else if (isDayOfWeek(input)) {
                output = getDayOfWeek(input);
            } else {
                output = LocalDate.now().plusDays(2);
            }
        }
        loggerParseDate.log(Level.INFO, "End of parseDate");
        return output;
    }

    public ArrayList<LocalTime> parseTime(String[] input, ArrayList<Integer> indices) {
        loggerParseTime.log(Level.INFO, "Start of parse time");

        ArrayList<LocalTime> output = new ArrayList<LocalTime>();

        for (int i = 0; i < indices.size(); i++) {
            output.add(toLocalTime(input[indices.get(i)]));
        }
        loggerParseTime.log(Level.INFO, "End of parseTime");
        return output;
    }

    protected boolean isDayOfWeek(String input) {
        return input.equalsIgnoreCase("monday") || input.equalsIgnoreCase("tuesday") || input
                .equalsIgnoreCase("wednesday") || input.equalsIgnoreCase("thursday") || input
                .equalsIgnoreCase("friday") || input.equalsIgnoreCase("saturday") || input
                .equalsIgnoreCase("sunday");
    }

    private boolean isEnglish(String input) {
        return (input.equalsIgnoreCase("today") || input.equalsIgnoreCase("tomorrow") || input
                .equalsIgnoreCase("next day") || input.equalsIgnoreCase("day after") || isDayOfWeek(input));
    }

    public LocalDate getDayOfWeek(String input) {

        if (input.equalsIgnoreCase("monday")) {
            return daysInWeek.getMonday();
        } else if (input.equalsIgnoreCase("tuesday")) {
            return daysInWeek.getTuesday();
        } else if (input.equalsIgnoreCase("wednesday")) {
            return daysInWeek.getWednesday();
        } else if (input.equalsIgnoreCase("thursday")) {
            return daysInWeek.getThursday();
        } else if (input.equalsIgnoreCase("friday")) {
            return daysInWeek.getFriday();
        } else if (input.equalsIgnoreCase("saturday")) {
            return daysInWeek.getSaturday();
        } else {
            return daysInWeek.getSunday();
        }
    }

    public boolean isDate(String input) {
        loggerIsDate.log(Level.INFO, "Start of isDate");

        if (input.equalsIgnoreCase("today") || input.equalsIgnoreCase("tomorrow") || input
                .equalsIgnoreCase("day after") || input.equalsIgnoreCase("next day") || isDayOfWeek(input)) {
            return true;

        } else {
            DateTimeFormatter formatterForDashes = DateTimeFormatter.ofPattern("dd-MM-yyyy");
            DateTimeFormatter formatterForSlashes = DateTimeFormatter.ofPattern("dd/MM/yyyy");
            DateTimeFormatter formatterEmpty = DateTimeFormatter.ofPattern("ddMMyyyy");
            DateTimeFormatter formatterDashesShortened = DateTimeFormatter.ofPattern("dd-MM-yy");
            DateTimeFormatter formatterSlashesShortened = DateTimeFormatter.ofPattern("dd/MM/yy");
            DateTimeFormatter formatterEmptyShortened = DateTimeFormatter.ofPattern("ddMMyy");

            try {
                LocalDate.parse(input, formatterForDashes);
                return true;
            } catch (Exception e) {
                loggerIsDate.log(Level.INFO, "Not dates  with dashes");

            }
            try {
                LocalDate.parse(input, formatterForSlashes);
                return true;
            } catch (Exception e) {
                loggerParseDate.log(Level.INFO, "Not date with slashes");
            }
            try {
                LocalDate.parse(input, formatterEmpty);
                return true;
            } catch (Exception e) {
                loggerParseDate.log(Level.INFO, "Not shortened date");
            }
            try {
                LocalDate.parse(input, formatterDashesShortened);
                return true;
            } catch (Exception e) {
                loggerParseDate.log(Level.INFO, "Not shortened date with dashes");
            }
            try {
                LocalDate.parse(input, formatterSlashesShortened);
                return true;
            } catch (Exception e) {
                loggerParseDate.log(Level.INFO, "Not shortened date with slashes");
            }
            try {
                LocalDate.parse(input, formatterEmptyShortened);
                return true;
            } catch (Exception e) {
                return false;
            }
        }
    }

    public boolean isTime(String input) {
        return (input.indexOf(':') >= 0);
    }

    public ArrayList<Integer> indicesToDetermineTime(String[] input) {

        ArrayList<Integer> indices = new ArrayList<Integer>();

        for (int i = 0; i < input.length; i++) {
            if (isTime(input[i])) {
                indices.add(i);
            }
        }
        return indices;
    }

    public ArrayList<Integer> indicesToDetermineDate(String[] input) {

        ArrayList<Integer> indices = new ArrayList<Integer>();

        for (int i = input.length; i > 1; i--) {

            String toCheck = input[i - 2] + " " + input[i - 1];

            if (isDate(input[i - 1])) {
                indices.add(i - 1);
                if (isEnglish(input[i - 1])) {
                    break;
                }
            } else if (isDate(toCheck)) {
                indices.add(i - 2);
                indices.add(i - 1);
                if (isEnglish(input[i - 2] + " " + input[i - 1])) {
                    break;
                }
            }
        }
        return indices;
    }

    private LocalTime toLocalTime(String input) {
        DateTimeFormatter timeColons = DateTimeFormatter.ofPattern("HH:mm");
        return LocalTime.parse(input, timeColons);
    }

    public String[] removeDate(String[] userCommand) {

        ArrayList<Integer> indices = new ArrayList<Integer>();
        indices = indicesToDetermineDate(userCommand);
        int numIndices = indices.size();
        ArrayList<String> tempUserCommand = new ArrayList<String>(Arrays.asList((userCommand)));

        if (numIndices == 0) {
            return userCommand;
        } else if (numIndices == 1) {
            int first = indices.get(0);
            tempUserCommand.remove(first);
        } else {
            int first = indices.get(0);
            int second = indices.get(1);

			/* Remove second one first to prevent indices from changing */
            if (first > second) {
                tempUserCommand.remove(first);
                tempUserCommand.remove(second);
            } else {
                tempUserCommand.remove(second);
                tempUserCommand.remove(first);
            }
        }
        return tempUserCommand.toArray(new String[tempUserCommand.size()]);
    }

    public String[] removeTime(String[] userCommand) {

        ArrayList<Integer> indices = new ArrayList<Integer>();
        indices = indicesToDetermineTime(userCommand);
        int numIndices = indices.size();
        ArrayList<String> tempUserCommand = new ArrayList<String>(Arrays.asList((userCommand)));

        if (numIndices == 0) {
            return userCommand;
        } else if (numIndices == 1) {
            int first = indices.get(0);
            tempUserCommand.remove(first);
        } else {
            int first = indices.get(0);
            int second = indices.get(1);

            if (first > second) {
                tempUserCommand.remove(first);
                tempUserCommand.remove(second);
            } else {
                tempUserCommand.remove(second);
                tempUserCommand.remove(first);
            }
        }
        return tempUserCommand.toArray(new String[tempUserCommand.size()]);
    }
}
```
###### QuickTasker\src\parser\DetermineCommandType.java
``` java

public class DetermineCommandType {

    public static Commands getCommand(String input) {
        switch (input.toLowerCase()) {
            case "add":
                return Commands.CREATE_TASK;
            case "del":
                return Commands.DELETE_TASK;
            case "remove":
                return Commands.DELETE_TASK;
            case "rm":
                return Commands.DELETE_TASK;
            case "delete":
                return Commands.DELETE_TASK;
            case "update":
                return Commands.UPDATE_TASK;
            case "sort":
                return Commands.SORT_TASK;
            case "search":
                return Commands.SEARCH_TASK;
            case "find":
                return Commands.SEARCH_TASK;
            case "show":
                return Commands.DISPLAY_TASK;
            case "view":
                return Commands.DISPLAY_TASK;
            case "back":
                return Commands.DISPLAY_TASK;
            case "mark":
                return Commands.MARK_TASK;
            case "undo":
                return Commands.UNDO_TASK;
            case "recur":
                return Commands.RECUR_TASK;
            case "exit":
                return Commands.EXIT;
            case "redo":
                return Commands.REDO_TASK;
            case "change":
                return Commands.CHANGE_DIRECTORY;
            case "switch":
                return Commands.CHANGE_DIRECTORY;
            case "help":
                return Commands.HELP;
            case "theme":
                return Commands.THEME;
            case "skip":
                return Commands.SKIP_TASK;
            case "stop":
                return Commands.STOP_TASK;
            case "clear":
                return Commands.CLEAR_TASK;
            default:
                return Commands.ERROR;
        }
    }

}
```
###### QuickTasker\src\parser\DirectoryParser.java
``` java

import java.util.logging.Level;
import java.util.logging.Logger;

public class DirectoryParser extends UserInputParser {
    private String filePath;
    private static Logger loggerFilePath = Logger.getLogger("getFilePath");

    private void setAttributesForChange(String userInput) {
        assert (userInput.length() > 0);
        removeWhiteSpaces(userInput);
        determineLengthOfInput();
        setFilePath();
    }

    private void setFilePath() {
        filePath = userCommand[1];
    }

    public String getFilePath(String userInput) {
        loggerFilePath.log(Level.INFO, "Start of getFilePath");
        setAttributesForChange(userInput);
        loggerFilePath.log(Level.INFO, "End of getFilePath");

        return filePath;
    }
}
```
###### QuickTasker\src\parser\ParserInterface.java
``` java

import java.time.LocalDate;
import java.time.LocalTime;

public interface ParserInterface {


    LocalDate getStartDate(String userInput) throws Exception;

    LocalDate getEndDate(String userInput) throws Exception;

    LocalTime getStartTime(String userInput) throws Exception;

    LocalTime getEndTime(String userInput) throws Exception;

    Commands getCommand(String userInput) throws Exception;

    LocalTime getStartTimeForUpdate(String userInput) throws Exception;

    LocalTime getEndTimeForUpdate(String userInput) throws Exception;

    String getTaskName(String userInput) throws Exception;

    String setTaskNameForUpdates() throws Exception;

    int getIndexForUpdates(String userInput);

    int getIndexForDone(String userInput);

    String getTaskNameForUpdate(String userInput) throws Exception;

    LocalDate getStartDateForUpdate(String userInput) throws Exception;

    LocalDate getEndDateForUpdate(String userInput) throws Exception;

    int getIndexForTaskNameUpdate();

    void setAttributesForUpdates(String input) throws Exception;

    int getTaskIndex(String userInput) throws Exception;

    String getRecurDuration(String userInput);

    LocalDate getTaskStartDate(String userInput);

    LocalDate getTaskEndDate(String userInput);

    LocalTime getTaskStartTime(String userInput);

    LocalTime getTaskEndTime(String userInput);

}
```
###### QuickTasker\src\parser\RecurringParser.java
``` java

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;


public class RecurringParser extends UserInputParser {

    private int numToRecur;
    private String recurDuration;
    private static Logger loggerRecur = Logger.getLogger("setNumToRecur in RecurringParser");

    private void setAttributesRecurring(String input) {
        DateTimeParser dateTimeParser = new DateTimeParser();
        removeWhiteSpaces(input);
        determineLengthOfInput();
        numToRecur = setNumToRecur();
        recurDuration = setRecurDuration();
        userCommand = removeNumAndDuration();
        determineLengthOfInput();
        setTime(userCommand);
        userCommand = dateTimeParser.removeTime(userCommand);
        determineLengthOfInput();
        isEnglishDate();
        setDate(numToUse, lengthOfInput);
        userCommand = dateTimeParser.removeDate(userCommand);
        determineLengthOfInput();
        setTaskName();
    }

    private String[] removeNumAndDuration() {
        ArrayList<String> tempUserCommand = new ArrayList<String>(Arrays.asList(userCommand));
        tempUserCommand.remove(lengthOfInput - 1);
        tempUserCommand.remove(lengthOfInput - 2);
        return tempUserCommand.toArray(new String[tempUserCommand.size()]);
    }

    public int setNumToRecur() {
        loggerRecur.log(Level.INFO, "Start of setNumToRecur");

        try {
            Integer.parseInt(userCommand[lengthOfInput - 2]);
        } catch (NumberFormatException e) {
            loggerRecur.log(Level.WARNING, "Error in processing number to recur", e);
        }
        loggerRecur.log(Level.INFO, "End of setNumToRecur");
        return Integer.parseInt(userCommand[lengthOfInput - 2]);
    }

    public String setRecurDuration() {
        return userCommand[lengthOfInput - 1];
    }

    public static LocalDate stringToLocalDate(String date) {
        DateTimeParser parser = new DateTimeParser();
        return parser.parseDate(date);
    }

    public int getNumToRecur(String userInput) {
        setAttributesRecurring(userInput);
        return numToRecur;

    }

    public String getRecurDuration(String userInput) {
        setAttributesRecurring(userInput);
        return recurDuration;

    }

    public String getTaskName(String userInput) {
        setAttributesRecurring(userInput);
        return taskName;
    }

    public LocalDate getTaskStartDate(String userInput) {
        setAttributesRecurring(userInput);
        return startDate;
    }

    public LocalDate getTaskEndDate(String userInput) {
        setAttributesRecurring(userInput);
        return endDate;
    }

    public LocalTime getTaskStartTime(String userInput) {
        setAttributesRecurring(userInput);
        return startTime;
    }

    public LocalTime getTaskEndTime(String userInput) {
        setAttributesRecurring(userInput);
        return endTime;
    }

    public int getIndexForUpdates(String userInput) {
        removeWhiteSpaces(userInput);
        return Integer.parseInt(userCommand[1]);
    }
}
```
###### QuickTasker\src\parser\SearchParser.java
``` java

public class SearchParser extends UserInputParser {

    private String toSearch;

    private void setAttributesSearch(String input) {
        removeWhiteSpaces(input);
        determineLengthOfInput();
        toSearch = setToSearch();
    }

    private String setToSearch() {
        String output = "";

        for (int i = 1; i < lengthOfInput; i++) {
            output += userCommand[i];
            output += " ";
        }
        output = output.trim();
        return output;
    }

    public String getWordsToSearch(String input) {
        setAttributesSearch(input);
        return toSearch;
    }

}
```
###### QuickTasker\src\parser\UpdateParser.java
``` java

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;

public class UpdateParser extends UserInputParser {
    private int numToRecur;
    private String durationToRecur;
    private final int INDEX_OF_TASK = 1;
    private static Logger loggerUpdate = Logger.getLogger("setAttributesForUpdates in UpdateParser");

    public void setAttributesForUpdates(String input) {
        loggerUpdate.log(Level.INFO, "Start of setAttributesForUpdates");

        DateTimeParser dateTimeParser = new DateTimeParser();
        removeWhiteSpaces(input);
        command = userCommand[0];
        determineLengthOfInput();
        userCommand = removeIndexToUpdate();
        determineLengthOfInput();

        loggerUpdate.log(Level.INFO, "Before checking if is floating update");

        if (!isFloatingUpdate()) {
            loggerUpdate.log(Level.INFO, "Not floating update");
            if (!isRecurUpdate()) {
                loggerUpdate.log(Level.INFO, "Not recurring update");
                if (!isTimeUpdate()) {
                    setTime(userCommand);
                    userCommand = dateTimeParser.removeTime(userCommand);
                    determineLengthOfInput();
                    isEnglishDate();
                    setDate(numToUse, lengthOfInput);
                    userCommand = dateTimeParser.removeDate(userCommand);
                    determineLengthOfInput();
                    setTaskNameForUpdates();
                } else {
                    setTime(userCommand);
                }
            } else {
                setNumToRecur();
                setDurationToRecur();
            }
        } else {
            loggerUpdate.log(Level.INFO, "Floating update");

            determineLengthOfInput();
            userCommand = removeFloatingWord(getIndexForTaskNameUpdate());
            determineLengthOfInput();
            setFloatingTaskNameUpdate();
            setDateFloating();
            setTimeFloating();
        }
        loggerUpdate.log(Level.INFO, "End of setAttributesForUpdates");
    }

    private void setDateFloating() {
        startDate = LocalDate.MIN;
        endDate = LocalDate.MAX;
    }

    private void setTimeFloating() {
        startTime = LocalTime.MIN;
        endTime = LocalTime.MAX;
    }

    private void setTaskNameForUpdates() {

        String output = "";

        for (int i = 1; i < lengthOfInput; i++) {
            System.out.println("I:  " + userCommand[i]);
            output += userCommand[i] + " ";
        }
        output = output.trim();
        taskName = output;
    }

    public int getIndexForUpdates(String userInput) {
        removeWhiteSpaces(userInput);
        return Integer.parseInt(userCommand[1]);
    }

    public String getTaskName(String userInput) {
        setAttributesForUpdates(userInput);
        return taskName;
    }

    public LocalDate getStartDate(String userInput) {
        setAttributesForUpdates(userInput);
        return startDate;
    }

    public LocalDate getEndDate(String userInput) {
        setAttributesForUpdates(userInput);
        return endDate;
    }

    public LocalTime getStartTime(String userInput) {
        setAttributesForUpdates(userInput);
        return startTime;
    }

    public LocalTime getEndTime(String userInput) {
        setAttributesForUpdates(userInput);
        return endTime;
    }

    private void setFloatingTaskNameUpdate() {
        String output = "";
        for (int i = 2; i < lengthOfInput; i++) {
            output += userCommand[i];
            output += " ";
        }
        output = output.trim();
        taskName = output;
    }

    private String[] removeFloatingWord(int indexToRemove) {
        ArrayList<String> tempUserCommand = new ArrayList<String>(Arrays.asList(userCommand));
        tempUserCommand.remove(indexToRemove);
        return tempUserCommand.toArray(new String[tempUserCommand.size()]);
    }

    private int getIndexForTaskNameUpdate() {
        int index = 0;
        for (int i = lengthOfInput; i > 0; i--) {

            if (userCommand[i - 1].equals("floating")) {
                index = i - 1;
                break;
            }
        }
        return index;
    }

    private String[] removeIndexToUpdate() {
        ArrayList<String> tempUserCommand = new ArrayList<String>(Arrays.asList((userCommand)));
        tempUserCommand.remove(INDEX_OF_TASK);
        return tempUserCommand.toArray(new String[tempUserCommand.size()]);
    }

    private boolean isFloatingUpdate() {
        boolean check = false;

        for (String s : userCommand) {
            if (s.equals("floating")) {
                check = true;
            }
        }
        return check;
    }

    private boolean isTimeUpdate() {
        DateTimeParser parser = new DateTimeParser();
        return lengthOfInput == 3 && parser.isTime(userCommand[lengthOfInput - 2]) && parser
                .isTime(userCommand[lengthOfInput - 1]);
    }

    private boolean isRecurUpdate() {
        return userCommand[1].equalsIgnoreCase("recur");
    }

    private void setNumToRecur() {
        numToRecur = Integer.parseInt(userCommand[lengthOfInput - 2]);
    }

    private void setDurationToRecur() {
        durationToRecur = userCommand[lengthOfInput - 1];
    }

    public int getNumToRecur(String input) {
        setAttributesForUpdates(input);
        return numToRecur;
    }

    public String getDurationToRecur(String input) {
        setAttributesForUpdates(input);
        return durationToRecur;
    }
}
```
###### QuickTasker\src\parser\UserInputParser.java
``` java

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

public class UserInputParser {

    protected String taskName;
    protected LocalDate startDate;
    protected LocalDate endDate;
    protected LocalTime startTime;
    protected LocalTime endTime;
    protected String command;
    protected String[] userCommand;
    protected int lengthOfInput;
    protected int numToUse;
    private static Logger loggerTaskName = Logger.getLogger("setTaskName");
    DateTimeParser dateTimeParser = new DateTimeParser();

    protected static final int NUMBER_NORMAL = 0;
    protected static final int NUMBER_TOMORROW = 1;
    protected static final int NUMBER_NEXT_DAY_DAY_AFTER = 2;
    protected static final int NUMBER_FLOATING = 3;
    protected static final int NUMBER_TODAY = 4;
    protected static final int NUMBER_ONLY_ONE_DATE = 5;
    protected static final int NUMBER_DAY_OF_WEEK = 6;

    public UserInputParser() {
        this.taskName = "";
        this.startDate = LocalDate.MIN;
        this.endDate = LocalDate.MIN;
        this.startTime = LocalTime.MIN;
        this.endTime = LocalTime.MIN;
        this.command = "";
    }

    public void setAttributes(String userInput) {

        DateTimeParser dateTimeParser = new DateTimeParser();

        removeWhiteSpaces(userInput);

        setTime(userCommand);
        userCommand = dateTimeParser.removeTime(userCommand);

        determineLengthOfInput();
        isEnglishDate();
        setDate(numToUse, lengthOfInput);
        userCommand = dateTimeParser.removeDate(userCommand);

        determineLengthOfInput();
        command = userCommand[0];
        setTaskName();
    }

    public void setAttributesForGetCommands(String userInput) {
        removeWhiteSpaces(userInput);
        determineLengthOfInput();
        command = userCommand[0];
    }

    public void setTaskName() {

        loggerTaskName.log(Level.INFO, "Start of process");
        String output = "";

        try {
            for (int i = 1; i < lengthOfInput; i++) {
                output += userCommand[i] + " ";
            }
            output = output.trim();

        } catch (Exception e) {
            loggerTaskName.log(Level.WARNING, "Error in taskname processing", e);
        }
        loggerTaskName.log(Level.INFO, "end of processing");

        taskName = output;
    }

    public String[] removeWhiteSpaces(String input) {

        try {
            userCommand = input.split("\\s+");
        } catch (Exception e) {
            System.out.println("Error in splitting");
            System.out.println("Please enter again");
        }
        return userCommand;
    }

    public void determineLengthOfInput() {
        lengthOfInput = userCommand.length;
    }

    private boolean isFloating() {

        return (!dateTimeParser.isDate(userCommand[lengthOfInput - 1]) && !dateTimeParser
                .isDate(userCommand[lengthOfInput - 2]) && !dateTimeParser
                .isDate("" + userCommand[lengthOfInput - 2] + userCommand[lengthOfInput - 1]));
    }

    public static LocalDate stringToLocalDate(String date) {
        DateTimeParser parser = new DateTimeParser();
        return parser.parseDate(date);
    }

    public LocalDate getStartDate(String userInput) {
        setAttributes(userInput);
        return startDate;
    }

    public LocalDate getEndDate(String userInput) {
        setAttributes(userInput);

        return endDate;
    }

    public LocalTime getStartTime(String userInput) {
        setAttributes(userInput);

        return startTime;
    }

    public LocalTime getEndTime(String userInput) {
        setAttributes(userInput);

        return endTime;
    }

    public String getTaskName(String userInput) {
        setAttributes(userInput);
        return taskName;
    }

    public int getTaskIndex(String input) {
        String[] splitted = input.split("\\s+");
        return Integer.parseInt(splitted[1]) - 1;
    }

    public Commands getCommand(String userInput) {
        setAttributesForGetCommands(userInput);
        return DetermineCommandType.getCommand(command);
    }

    public int getIndexForDone(String userInput) {
        removeWhiteSpaces(userInput);
        return Integer.parseInt(userCommand[1]) - 1;
    }

    public void setDate(int numToSetDate, int length) {
        if (numToSetDate == NUMBER_NORMAL) {
            startDate = stringToLocalDate(userCommand[length - 2]);
            endDate = stringToLocalDate(userCommand[length - 1]);
        } else if (numToSetDate == NUMBER_TOMORROW) {
            startDate = endDate = stringToLocalDate("tomorrow");
        } else if (numToSetDate == NUMBER_NEXT_DAY_DAY_AFTER) {
            startDate = endDate = stringToLocalDate(userCommand[length - 2] + " " + userCommand[length - 1]);
        } else if (numToSetDate == NUMBER_FLOATING) {
            startDate = LocalDate.MIN;
            endDate = LocalDate.MAX;//
        } else if (numToSetDate == NUMBER_TODAY) {
            startDate = endDate = stringToLocalDate("today");
        } else if (numToSetDate == NUMBER_ONLY_ONE_DATE) {
            startDate = LocalDate.MIN;
            endDate = stringToLocalDate(userCommand[length - 1]);
        } else if (numToSetDate == NUMBER_DAY_OF_WEEK) {
            startDate = dateTimeParser.getDayOfWeek(userCommand[length - 1]);
            endDate = dateTimeParser.getDayOfWeek(userCommand[length - 1]);
        }
    }

    public void setTime(String[] input) {
        DateTimeParser parser = new DateTimeParser();
        ArrayList<Integer> indicesTime = parser.indicesToDetermineTime(input);

        if (indicesTime.size() == 0) {
            startTime = LocalTime.MIN;
            endTime = LocalTime.MAX;
        }
        ArrayList<LocalTime> localTimes = parser.parseTime(input, indicesTime);

        if (indicesTime.size() == 1) {
            startTime = localTimes.get(0);
            endTime = LocalTime.MAX;
        }
        if (indicesTime.size() == 2) {
            startTime = localTimes.get(0);
            endTime = localTimes.get(1);
        }
    }

    protected void isEnglishDate() {

        String toCheck = userCommand[lengthOfInput - 2] + " " + userCommand[lengthOfInput - 1];

        if (userCommand[lengthOfInput - 1].equalsIgnoreCase("tomorrow")) {
            numToUse = NUMBER_TOMORROW;
        } else if (toCheck.equalsIgnoreCase("next day") || toCheck.equalsIgnoreCase("day after")) {
            numToUse = NUMBER_NEXT_DAY_DAY_AFTER;
        } else if (isFloating()) {
            numToUse = NUMBER_FLOATING;
        } else if (userCommand[lengthOfInput - 1].equalsIgnoreCase("today")) {
            numToUse = NUMBER_TODAY;
        } else if (dateTimeParser.isDayOfWeek(userCommand[lengthOfInput - 1]) && !dateTimeParser
                .isDate(userCommand[lengthOfInput - 2])) {
            numToUse = NUMBER_DAY_OF_WEEK;
        } else if (dateTimeParser.isDate(userCommand[lengthOfInput - 1]) && !dateTimeParser
                .isDate(userCommand[lengthOfInput - 2])) {
            numToUse = NUMBER_ONLY_ONE_DATE;
        } else {
            numToUse = NUMBER_NORMAL;
        }
    }
}

```
###### QuickTasker\src\ui\controller\InputValidator.java
``` java

import javafx.collections.ObservableList;
import model.Task;
import parser.Commands;
import parser.RecurringParser;
import parser.UpdateParser;
import parser.UserInputParser;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.logging.Level;
import java.util.logging.Logger;

public class InputValidator {
    private static Logger loggerValidator = Logger.getLogger("checkIfValid in InputValidator");
    private  UserInputParser userInputParser;
    private  RecurringParser recurringParser;
    Commands cmd;

    public boolean checkAllValid(String userInput) {
        return isAllValid(userInput);
    }

    private static boolean isNull(String input) {
        return input.isEmpty();
    }

    private boolean checkUndoRedo(String input) {
        userInputParser= new UserInputParser();

        cmd = userInputParser.getCommand(input);

        if (cmd == Commands.UNDO_TASK || cmd == Commands.REDO_TASK) {
            return true;
        }
        return false;
    }

    private boolean checkCommand(String input) {
        userInputParser= new UserInputParser();

        cmd = userInputParser.getCommand(input);

        for (Commands c : Commands.values()) {
            if (cmd == c) {
                return true;
            }
        }
        return false;
    }

    private boolean checkTaskName(String input) {
        if (cmd == Commands.CREATE_TASK) {
            userInputParser=new UserInputParser();
            return userInputParser.getTaskName(input).length() != 0;
        } else if (cmd == Commands.RECUR_TASK) {
            recurringParser= new RecurringParser();
            return recurringParser.getTaskName(input).length() != 0;
        } else {
            return true;
        }
    }

    private boolean checkTime(String input) {
        if (cmd == Commands.CREATE_TASK) {
            userInputParser= new UserInputParser();
            LocalDate startAddDate = userInputParser.getStartDate(input);
            LocalDate endAddDate = userInputParser.getEndDate(input);
            LocalTime startAddTime = userInputParser.getStartTime(input);
            LocalTime endAddTime = userInputParser.getEndTime(input);
            if (isSameDate(startAddDate, endAddDate) && isTimeAvailable(startAddTime, endAddTime)) {
                return endAddTime.isAfter(startAddTime);
            }
            return true;
        } else if (cmd == Commands.RECUR_TASK) {
            recurringParser= new RecurringParser();
            LocalDate startRecurDate = recurringParser.getStartDate(input);
            LocalDate endRecurDate = recurringParser.getEndDate(input);
            LocalTime startRecur = recurringParser.getStartTime(input);
            LocalTime endRecur = recurringParser.getEndTime(input);
            if (isSameDate(startRecurDate, endRecurDate) && isTimeAvailable(startRecur, endRecur)) {
                return endRecur.isAfter(startRecur);
            }
            return true;
        }
        return true;
    }

    private boolean isSameDate(LocalDate start, LocalDate end) {
        return start.isEqual(end);
    }

    private boolean checkDate(String input) {
        if (cmd == Commands.CREATE_TASK) {
            userInputParser= new UserInputParser();
            LocalDate startAdd = userInputParser.getStartDate(input);
            LocalDate endAdd = userInputParser.getEndDate(input);
            if (isDateAvailable(startAdd, endAdd)) {
                return endAdd.isAfter(startAdd) || endAdd.isEqual(startAdd);
            }
            return true;
        } else if (cmd == Commands.RECUR_TASK) {
            recurringParser= new RecurringParser();
            LocalDate startRecur = recurringParser.getStartDate(input);
            LocalDate endRecur = recurringParser.getEndDate(input);
            if (isDateAvailable(startRecur, endRecur)) {
                return endRecur.isAfter(startRecur) || endRecur.isEqual(startRecur);
            }
            return true;
        }
        return true;
    }

    private boolean isTimeAvailable(LocalTime start, LocalTime end) {
        return !(start == LocalTime.MIN) || !(end == LocalTime.MAX);
    }

    private boolean isDateAvailable(LocalDate start, LocalDate end) {
        return !(start == LocalDate.MIN) && !(end == LocalDate.MAX);
    }

    // Checks if the added task will have any clashes with any range of tasks in
    // the list.
    public boolean checkIfClash(ObservableList<Task> list, Task task) {
        loggerValidator.log(Level.INFO, "Start of checkIfClash");

        LocalDate startDate = task.getStartDate();
        LocalDate endDate = task.getDueDate();
        LocalTime startTime = task.getStartTime();
        LocalTime endTime = task.getEndTime();
        loggerValidator.log(Level.INFO, "Before checking if two localdates");

        if (isNotTwoDates(startDate, endDate)) {
            return false;
        } else if (isOneDate(startDate, endDate)) {
            return false;
        } else {
            for (Task t : list) {
                if (isDaysOverlap(t, startDate, endDate)) {
                    return true;
                } else if (isSameDates(t, startDate, endDate)) {
                    if (isTimeOverlap(t, startTime, endTime)) {
                        return true;
                    } else {
                        continue;
                    }
                }
            }
        }
        loggerValidator.log(Level.INFO, "End of checkIfClash");
        return false;
    }

    private boolean isOneDate(LocalDate start, LocalDate end) {

        return (start.isEqual(LocalDate.MIN) && !end.isEqual(LocalDate.MAX)) || (!start.isEqual(LocalDate.MIN)
                && end.isEqual(LocalDate.MAX));
    }

    public boolean isAllValid(String input) {
        boolean check = false;

        if (checkUndoRedo(input)) {
            return true;
        }
        check = !isNull(input) && checkCommand(input) && checkTaskName(input) && checkDate(input)
                && checkTime(input);
        return check;
    }

    private boolean isNotTwoDates(LocalDate start, LocalDate end) {
        return start == LocalDate.MAX || end == LocalDate.MAX || start == LocalDate.MIN
                || end == LocalDate.MIN;
    }

    private boolean isDaysOverlap(Task t, LocalDate start, LocalDate end) {
        return (start.isBefore(t.getDueDate()) || start.isEqual(t.getDueDate())) && (
                end.isAfter(t.getStartDate()) || end.isEqual(t.getStartDate()));
    }

    private boolean isSameDates(Task t, LocalDate start, LocalDate end) {
        return start.isEqual(t.getStartDate()) && end.equals(t.getDueDate());
    }

    private boolean isTimeOverlap(Task t, LocalTime start, LocalTime end) {
        return (start.isBefore(t.getEndTime()) || start.equals(t.getEndTime())) && (
                end.isAfter(t.getStartTime()) || end.equals(t.getStartTime()));
    }
}
```
###### QuickTasker\src\ui\controller\MainWindowController.java
``` java
    protected void showTasks(String userInput) {
        String whatToShow = determineShow(userInput);
        if (whatToShow.equals("all")) {
            showAll();
        } else if (whatToShow.equals("today")) {
            showToday();
        } else if (whatToShow.equals("tomorrow")) {
            showTomorrow();
        } else if (whatToShow.equals("floating")) {
            showFloating();
        } else if (whatToShow.equals("monday")) {
            showMonday();
        } else if (whatToShow.equals("tuesday")) {
            showTuesday();
        } else if (whatToShow.equals("wednesday")) {
            showWednesday();
        } else if (whatToShow.equals("thursday")) {
            showThursday();
        } else if (whatToShow.equals("friday")) {
            showFriday();
        } else if (whatToShow.equals("saturday")) {
            showSaturday();
        } else if (whatToShow.equals("sunday")) {
            showSunday();
        } else if (whatToShow.equals("overdue")) {
            showOverdue();
        } else {
            viewArchived();
        }
    }

    private String determineShow(String input) {
        String[] withoutWhiteSpaces = input.split("\\s+");
        return withoutWhiteSpaces[1];
    }

    void showTomorrow() {
        printedPlanner.setItems(plannerEntries.filtered(task -> search.isItDisplayedInTomorrowView(task)));
        headerTitle.setText("Tasks: Tomorrow");
        updateTaskCounter();
        commandBox.clear();
    }
        void showOverdue() {
        printedPlanner.setItems(plannerEntries.filtered(task -> search.isTaskOverdue(task)));
        headerTitle.setText("Tasks: Overdue");
        setWarningIcon();
        updateTaskCounter();
        commandBox.clear();
    }
       void showFloating() {
        printedPlanner.setItems(plannerEntries.filtered(task -> search.isFloatingTask(task)));
        headerTitle.setText("Tasks: Floating");
        updateTaskCounter();
        commandBox.clear();
    }
```
###### QuickTasker\src\ui\controller\UiOperationDelegator.java
``` java

import common.InvalidStringException;
import common.UIOperationException;
import parser.Commands;

public class UiOperationDelegator {
    private final MainWindowController mainWindowController;

    public UiOperationDelegator(MainWindowController mainWindowController) {
        this.mainWindowController = mainWindowController;
    }

    public void performOperations(String userInput) throws UIOperationException, InvalidStringException {
        InputValidator inputValidator = new InputValidator();
        if (!inputValidator.checkAllValid(userInput)) {
            MainWindowController.logger.severe(inputValidator.toString());
            throw new InvalidStringException();
        }
        try {
            if (mainWindowController.getParser().getCommand(userInput) == Commands.CREATE_TASK)
                mainWindowController.addTask(userInput);
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.DELETE_TASK)
                mainWindowController.deleteTask(userInput);
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.UPDATE_TASK)
                mainWindowController.updateTask(userInput);
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.UNDO_TASK)
                mainWindowController.undoTask();
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.REDO_TASK)
                mainWindowController.redoTask();
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.EXIT)
                mainWindowController.getOperations().exit();
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.MARK_TASK)
                mainWindowController.markTaskCompleted(userInput);
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.RECUR_TASK)
                mainWindowController.addRecurringTask(userInput);
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.SKIP_TASK)
                mainWindowController.skipRecurringTask(userInput);
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.CLEAR_TASK)
                mainWindowController.clearTasks();
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.STOP_TASK)
                mainWindowController.stopRecurringTask(userInput);
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.SEARCH_TASK)
                mainWindowController.searchTask(userInput);
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.CHANGE_DIRECTORY)
                mainWindowController.changeDirectory(userInput);
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.BACK)
                mainWindowController.showAll();
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.DISPLAY_TASK)
                mainWindowController.showTasks(userInput);
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.THEME)
                mainWindowController.changeTheme(userInput);
            else if (mainWindowController.getParser().getCommand(userInput) == Commands.HELP)
                mainWindowController.showHelp();
        } catch (Exception e) {
            throw new UIOperationException();
        }
    }
}
```
###### QuickTasker\tests\parser\DateTimeParserTest.java
``` java

import org.junit.Before;
import org.junit.Test;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

public class DateTimeParserTest {
    DateTimeParser parser;
    LocalDate date;
    LocalTime time;
    String[] timeList = { "12:12" };
    ArrayList<Integer> indices = new ArrayList<Integer>() {
        {
            add(0);
        }
    };

    @Before
    public void setUp() throws Exception {
        parser = new DateTimeParser();
    }

    @Test
    public void testParseDate() {
        date = LocalDate.of(2012, 12, 12);
        String input = "121212";
        assertEquals(date, parser.parseDate(input));
    }

    @Test
    public void testParseTime() {
        time = LocalTime.of(12, 12);
        ArrayList<LocalTime> toCheck = parser.parseTime(timeList, indices);

        assertEquals(time, toCheck.get(0));

    }

}
```
###### QuickTasker\tests\parser\RecurringParserTest.java
``` java

import org.junit.Test;

import java.time.LocalDate;
import java.time.LocalTime;

import static org.junit.Assert.assertEquals;

public class RecurringParserTest {
    RecurringParser parser;
    LocalDate startDate;
    LocalDate endDate;
    LocalTime startTime;
    LocalTime endTime;
    int numToRecur;
    String recurDuration;
    String userCommandTomorrow = "recur buy dog tomorrow 13:00 15:00 3 days";
    String userCommandDayAfter = "recur buy dog day after 13:00 15:00 3 days";
    String userCommandNormal = "recur buy dog 121212 131212 13:00 15:00 3 days";
    String userCommandDatesOnly = "recur buy dog next day 3 days";

    @Test
    public void testDatesOnly() {
        parser = new RecurringParser();
        assertEquals(3, parser.getNumToRecur(userCommandDatesOnly));
        assertEquals("days", parser.getRecurDuration(userCommandDatesOnly));
        assertEquals("buy dog", parser.getTaskName(userCommandDatesOnly));
        assertEquals(LocalDate.now().plusDays(1), parser.getTaskStartDate(userCommandDatesOnly));
        assertEquals(LocalDate.now().plusDays(1), parser.getTaskEndDate(userCommandDatesOnly));
        assertEquals(LocalTime.MIN, parser.getTaskStartTime(userCommandDatesOnly));
        assertEquals(LocalTime.MAX, parser.getTaskEndTime(userCommandDatesOnly));

    }

    @Test
    public void testTomorrow() {
        parser = new RecurringParser();
        assertEquals(3, parser.getNumToRecur(userCommandTomorrow));
        assertEquals("days", parser.getRecurDuration(userCommandTomorrow));
        assertEquals("buy dog", parser.getTaskName(userCommandTomorrow));
        assertEquals(LocalDate.now().plusDays(1), parser.getTaskStartDate(userCommandTomorrow));
        assertEquals(LocalDate.now().plusDays(1), parser.getTaskEndDate(userCommandTomorrow));
        assertEquals(LocalTime.of(13, 00), parser.getTaskStartTime(userCommandTomorrow));
        assertEquals(LocalTime.of(15, 00), parser.getTaskEndTime(userCommandTomorrow));

    }

    @Test
    public void testDayAfter() {
        parser = new RecurringParser();
        assertEquals(3, parser.getNumToRecur(userCommandDayAfter));
        assertEquals("days", parser.getRecurDuration(userCommandDayAfter));
        assertEquals("buy dog", parser.getTaskName(userCommandDayAfter));
        assertEquals(LocalDate.now().plusDays(2), parser.getTaskStartDate(userCommandDayAfter));
        assertEquals(LocalDate.now().plusDays(2), parser.getTaskEndDate(userCommandDayAfter));
        assertEquals(LocalTime.of(13, 00), parser.getTaskStartTime(userCommandDayAfter));
        assertEquals(LocalTime.of(15, 00), parser.getTaskEndTime(userCommandDayAfter));

    }

    @Test
    public void testGetNumToRecur() {
        parser = new RecurringParser();
        assertEquals(3, parser.getNumToRecur(userCommandNormal));
    }

    @Test
    public void testGetRecurDuration() {
        parser = new RecurringParser();
        assertEquals("days", parser.getRecurDuration(userCommandNormal));
    }

    @Test
    public void testGetTaskName() {
        parser = new RecurringParser();
        assertEquals("buy dog", parser.getTaskName(userCommandNormal));
    }

    @Test
    public void testGetTaskStartDate() {
        parser = new RecurringParser();
        assertEquals(LocalDate.of(2012, 12, 12), parser.getTaskStartDate(userCommandNormal));
    }

    @Test
    public void testGetTaskEndDate() {
        parser = new RecurringParser();
        assertEquals(LocalDate.of(2012, 12, 13), parser.getTaskEndDate(userCommandNormal));
    }

    @Test
    public void testGetTaskStartTime() {
        parser = new RecurringParser();
        assertEquals(LocalTime.of(13, 00), parser.getTaskStartTime(userCommandNormal));
    }

    @Test
    public void testGetTaskEndTime() {
        parser = new RecurringParser();
        assertEquals(LocalTime.of(15, 00), parser.getTaskEndTime(userCommandNormal));
    }
}
```
###### QuickTasker\tests\parser\UpdateParserTest.java
``` java

import org.junit.Before;
import org.junit.Test;

import java.time.LocalDate;
import java.time.LocalTime;

import static org.junit.Assert.assertEquals;

public class UpdateParserTest {
    UpdateParser parser;
    LocalDate date;
    LocalTime time;
    String stringToTest = "update 1 buy groceries 121212 121213 09:00 10:00";
    String stringForRecur = "update 1 recur 3 weeks";
    String stringOnlyName = "update 1 update 3 weeks";
    String stringOnlyTime = "update 1 13:00 15:00";

    @Before
    public void setUp() throws Exception {
        parser = new UpdateParser();
    }

    @Test
    public void testGetStartDate() {

        assertEquals(LocalDate.of(2012, 12, 12), parser.getStartDate(stringToTest));
    }

    @Test
    public void testGetEndDate() {
        assertEquals(LocalDate.of(2013, 12, 12), parser.getEndDate(stringToTest));
    }

    @Test
    public void testGetStartTime() {
        assertEquals(LocalTime.of(9, 00), parser.getStartTime(stringToTest));
    }

    @Test
    public void testGetEndTime() {
        assertEquals(LocalTime.of(10, 00), parser.getEndTime(stringToTest));
    }

    @Test
    public void testGetTaskName() {
        assertEquals("buy groceries", parser.getTaskName(stringToTest));
    }

    @Test
    public void testGetIndex() {
        parser.setAttributesForUpdates(stringToTest);
        assertEquals(1, parser.getIndexForUpdates(stringToTest));
    }

    @Test
    public void testRecurUpdatesNum() {
        assertEquals(3, parser.getNumToRecur(stringForRecur));
    }

    @Test
    public void testRecurUpdatesDuration() {
        assertEquals("weeks", parser.getDurationToRecur(stringForRecur));
    }

    @Test
    public void testUpdateNameOnly() {
        assertEquals("update 3 weeks", parser.getTaskName(stringOnlyName));
    }

    @Test
    public void testTimeOnly() {
        assertEquals(LocalTime.of(13, 00), parser.getStartTime(stringOnlyTime));
        assertEquals(LocalTime.of(15, 00), parser.getEndTime(stringOnlyTime));
    }
}
```
###### QuickTasker\tests\parser\UserInputParserTest.java
``` java

import org.junit.Before;
import org.junit.Test;

import java.time.LocalDate;
import java.time.LocalTime;

import static org.junit.Assert.assertEquals;

public class UserInputParserTest {
    UserInputParser parser;
    LocalDate startDate;
    LocalDate endDate;
    LocalTime startTime;
    LocalTime endTime;
    String userCommand = "add biology class tomorrow 13:00 15:00";

    @Before
    public void setUp() throws Exception {
        parser = new UserInputParser();
    }

    @Test
    public void testSetDate() {
        parser.setDate(1, 4);
        assertEquals(LocalDate.now().plusDays(1), parser.getStartDate(userCommand));
    }

    @Test
    public void testSetTime() {
        assertEquals(LocalTime.of(13, 00), parser.getStartTime(userCommand));
        assertEquals(LocalTime.of(15, 00), parser.getEndTime(userCommand));
    }

}
```
###### QuickTasker\tests\ui\controller\InputValidatorTest.java
``` java

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import logic.Logic;
import model.Task;
import org.junit.Before;
import org.junit.Test;

import java.time.LocalDate;
import java.time.LocalTime;

import static org.junit.Assert.assertEquals;

public class InputValidatorTest {
    private final Logic operations = new Logic();
    InputValidator validator;
    ObservableList<Task> list;
    Task toTest;

    @Before
    public void setUp() throws Exception {
        validator = new InputValidator();
    }

    @Test
    public void testCheckIfClashSameTimeOverlapDates() {
        list = FXCollections.observableArrayList(operations.addTask(
                new Task("TEST 1", LocalDate.of(2016, 4, 6), LocalDate.of(2016, 4, 25), LocalTime.of(9, 00),
                        LocalTime.of(13, 00))));
        toTest = new Task("TEST 2", LocalDate.of(2016, 4, 4), LocalDate.of(2016, 4, 22), LocalTime.of(9, 00),
                LocalTime.of(13, 00));
        assertEquals(validator.checkIfClash(list, toTest), true);

    }

    @Test
    public void testCheckIfClashOverlapTimeSameDates() {
        list = FXCollections.observableArrayList(operations.addTask(
                new Task("TEST 1", LocalDate.of(2016, 4, 6), LocalDate.of(2016, 4, 6), LocalTime.of(9, 00),
                        LocalTime.of(13, 00))));
        toTest = new Task("TEST 2", LocalDate.of(2016, 4, 6), LocalDate.of(2016, 4, 6), LocalTime.of(8, 00),
                LocalTime.of(12, 00));
        assertEquals(validator.checkIfClash(list, toTest), true);
    }
}
```
