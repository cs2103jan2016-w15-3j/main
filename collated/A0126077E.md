# A0126077E
###### resources\fxml\MainWindowView.fxml
``` fxml
<?import com.jfoenix.controls.*?>
<?import de.jensd.fx.glyphs.materialdesignicons.MaterialDesignIconView?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.*?>
<BorderPane fx:id="root" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/8.0.65"
            fx:controller="ui.controller.MainWindowController">
    <center>
        <StackPane fx:id="overlayPane" BorderPane.alignment="BOTTOM_CENTER">
            <children>
                <AnchorPane fx:id="mainContentContainer" minHeight="150.0" minWidth="500.0"
                            prefHeight="300.0"
                            prefWidth="400.0"
                            styleClass="root">
                    <AnchorPane fx:id="printedPlannerContainer" AnchorPane.bottomAnchor="20.0"
                                AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0"
                                AnchorPane.topAnchor="1.0">
                        <children>
                            <JFXListView fx:id="printedPlanner" cache="true" cacheHint="SPEED"
                                         minHeight="150.0"
                                         prefHeight="250.0" prefWidth="600.0" styleClass="list-view"
                                         AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="5.0"
                                         AnchorPane.rightAnchor="1.0" AnchorPane.topAnchor="0.0"/>
                        </children>
                    </AnchorPane>
                </AnchorPane>
                <JFXSnackbar fx:id="snackbar"/>
            </children>
        </StackPane>
    </center>
    <bottom>
        <AnchorPane fx:id="commandBoxContainer" styleClass="container"
                    BorderPane.alignment="BOTTOM_CENTER">
            <JFXTextField fx:id="commandBox" alignment="BOTTOM_CENTER" cache="true"
                          cacheHint="SPEED" labelFloat="true"
                          maxWidth="500.0" minWidth="100.0" onKeyPressed="#handleEnterKeyPressed"
                          prefHeight="30.0"
                          prefWidth="500.0" promptText="Enter command :" styleClass="text-box"
                          AnchorPane.bottomAnchor="10.0" AnchorPane.leftAnchor="0.0"
                          AnchorPane.rightAnchor="0.0"/>
            <BorderPane.margin>
                <Insets/>
            </BorderPane.margin>

        </AnchorPane>
    </bottom>
    <top>
        <VBox fx:id="headerWrapper" spacing="20" styleClass="header-wrapper">
            <JFXToolbar fx:id="headerContainer" styleClass="header-container">
                <left>
                    <JFXRippler alignment="BASELINE_LEFT" maskType="CIRCLE" ripplerFill="WHITE"
                                style="-fx-ripple-color:WHITE;">
                        <StackPane styleClass="badge-container">
                            <JFXBadge fx:id="tasksCounter" position="TOP_RIGHT"
                                      styleClass="icons-badge" text="1"
                                      BorderPane.alignment="CENTER">
                                <MaterialDesignIconView glyphName="ARCHIVE" size="2.5em"
                                                        styleClass="icon"
                                                        textAlignment="CENTER" textOrigin="CENTER"/>
                            </JFXBadge>
                        </StackPane>
                    </JFXRippler>
                </left>
                <center>
                    <Label fx:id="headerTitle" alignment="CENTER" styleClass="title-label"
                           textOverrun="CLIP"
                           BorderPane.alignment="CENTER">All Tasks
                    </Label>
                </center>
                <opaqueInsets>
                    <Insets/>
                </opaqueInsets>
                <VBox.margin>
                    <Insets/>
                </VBox.margin>
                <padding>
                    <Insets right="30.0"/>
                </padding>
            </JFXToolbar>
        </VBox>
    </top>
</BorderPane>
```
###### src\data\AvailableSettings.java
``` java
public enum AvailableSettings {
    SAVE_LOCATION,
    APP_THEME,
    APP_WIDTH,
    APP_HEIGHT;
}
```
###### src\data\DataHandler.java
``` java

import model.Task;

import java.util.List;

public interface DataHandler {

    List<Task> getTasks();

    void save(Task t);

    void save(List<Task> ts);

    void setSavePath(String path);

    void reset();
}
```
###### src\data\DefaultSettings.java
``` java

import ui.model.ApplicationColor;

import java.util.Properties;

public class DefaultSettings {
    private Properties properties = new Properties();

    public DefaultSettings() {
        setDefaults();
    }

    public Properties getDefaults() {
        return properties;
    }

    public Properties setDefaults() {

        properties.setProperty(AvailableSettings.APP_THEME.name(), ApplicationColor.RED.name());
        properties.setProperty(AvailableSettings.SAVE_LOCATION.name(), "tasks.json");
        properties.setProperty(AvailableSettings.APP_HEIGHT.name(), "560");
        properties.setProperty(AvailableSettings.APP_WIDTH.name(), "160");

        return properties;
    }

}
```
###### src\data\JsonDataHandler.java
``` java

import com.fatboyindustrial.gsonjavatime.Converters;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import common.CreateSaveFileException;
import common.LoadTasksException;
import common.SaveTasksException;
import model.RecurringTask;
import model.Task;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.DirectoryNotEmptyException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

public class JsonDataHandler implements DataHandler {
    private static final Logger logger = Logger.getLogger(JsonDataHandler.class.getName());

    private static final String DEFAULT_FILENAME = "tasks.json";
    private static final Path DEFAULT_SAVE_PATH = Paths.get(DEFAULT_FILENAME);
    private SettingManager settings = new SettingManagerImpl();
    private Path pathOfSaveFile;

    public JsonDataHandler() {

        initialize();
    }

    private void initialize() {
        loadSavePathFromSettingManager();
        if (Files.notExists(pathOfSaveFile)) createSaveFileIfNotExist();
    }

    private void loadSavePathFromSettingManager() {
        String p = settings.getPathOfSaveFile();
        pathOfSaveFile = p != null ? Paths.get(p) : DEFAULT_SAVE_PATH;
    }

    private void createSaveFileIfNotExist() throws CreateSaveFileException {
        try {
            if (pathOfSaveFile.getParent() != null && !Files.isRegularFile(pathOfSaveFile))
                Files.createDirectories(pathOfSaveFile.getParent());
            if (!Files.exists(pathOfSaveFile)) Files.createFile(pathOfSaveFile);
        } catch (IOException e) {
            logger.warning(e.toString());
            throw new CreateSaveFileException();
        }
    }

    @Override
    public List<Task> getTasks() throws LoadTasksException {
        Gson gson = getGson();
        List<Task> tasks;
        try (BufferedReader reader = Files.newBufferedReader(pathOfSaveFile)) {
            tasks = gson.fromJson(reader, new TypeToken<List<Task>>() {}.getType());
            reader.close();
            return tasks != null ? tasks : new ArrayList<>();
        } catch (IOException e) {
            throw new LoadTasksException();
        }
    }

    private Gson getGson() {
        return Converters.registerLocalDateTime(new GsonBuilder().setPrettyPrinting()
                .registerTypeAdapterFactory(
                        RuntimeTypeAdapterFactory.of(Task.class).registerSubtype(Task.class)
                                .registerSubtype(RecurringTask.class))).create();
    }

    @Override
    public void save(Task t) throws SaveTasksException {
        loadSavePathFromSettingManager();
        createSaveFileIfNotExist();
        Gson gson = getGson();
        String json = gson.toJson(t);
        try (BufferedWriter writer = Files.newBufferedWriter(pathOfSaveFile)) {
            writer.write(json);
        } catch (IOException e) {
            e.printStackTrace();
            throw new SaveTasksException();
        }
    }

    @Override
    public void save(List<Task> ts) throws SaveTasksException {
        loadSavePathFromSettingManager();
        createSaveFileIfNotExist();
        Gson gson = getGson();
        String json = gson.toJson(ts);
        try (BufferedWriter writer = Files.newBufferedWriter(pathOfSaveFile)) {
            writer.write(json);

        } catch (IOException e) {
            e.printStackTrace();
            throw new SaveTasksException();
        }
    }

    @Override
    public void reset() {
        Path p = Paths.get(settings.getPathOfSaveFile());
        try {
            Files.deleteIfExists(p);
        } catch (DirectoryNotEmptyException e) {
            logger.log(Level.WARNING, "Try to delete non-empty directory " + p.getFileName() +
                    " at reset() method in < " + getClass().getName() + "> class");
        } catch (SecurityException se) {
            logger.log(Level.WARNING, "Permission error while deleting " + p.getFileName() +
                    " at reset() method in < " + getClass().getName() + "> class");
        } catch (IOException ioe) {
            logger.log(Level.WARNING, "Unknow IOException occurs while deleting " + p.getFileName() +
                    "at reset() method in <" + getClass().getName() + "> class");
        }
        initialize();
    }

    Path getFilePath() {
        return this.pathOfSaveFile;
    }

    @Override
    public void setSavePath(String path) {
        this.pathOfSaveFile = Paths.get(path);
        settings.setPathOfSaveFile(path);

    }
}
```
###### src\data\RuntimeTypeAdapterFactory.java
``` java

import com.google.gson.*;
import com.google.gson.internal.Streams;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;

public final class RuntimeTypeAdapterFactory<T> implements TypeAdapterFactory {
    private final Class<?> baseType;
    private final String typeFieldName;
    private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<String, Class<?>>();
    private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<Class<?>, String>();

    private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
        if (typeFieldName == null || baseType == null) throw new NullPointerException();
        this.baseType = baseType;
        this.typeFieldName = typeFieldName;
    }

    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {
        return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName);
    }

    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {
        return new RuntimeTypeAdapterFactory<T>(baseType, "type");
    }

    public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, String label) {
        if (type == null || label == null) throw new NullPointerException();
        if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label))
            throw new IllegalArgumentException("types and labels must be unique");
        labelToSubtype.put(label, type);
        subtypeToLabel.put(type, label);
        return this;
    }

    public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {
        return registerSubtype(type, type.getSimpleName());
    }

    public <R> TypeAdapter<R> create(Gson g, TypeToken<R> type) {
        if (type == null || !baseType.isAssignableFrom(type.getRawType())) return null;

        final Map<String, TypeAdapter<?>> labelToDelegate = new LinkedHashMap<String, TypeAdapter<?>>();
        final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate = new LinkedHashMap<Class<?>, TypeAdapter<?>>();
        for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {
            TypeAdapter<?> delegate = g.getDelegateAdapter(this, TypeToken.get(entry.getValue()));
            labelToDelegate.put(entry.getKey(), delegate);
            subtypeToDelegate.put(entry.getValue(), delegate);
        }

        return new TypeAdapter<R>() {
            @Override
            public R read(JsonReader in) throws IOException {
                JsonElement jsonElement = Streams.parse(in);
                JsonElement labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);
                if (labelJsonElement == null) throw new JsonParseException(
                        "cannot deserialize " + baseType + " because it does not define a field named "
                                + typeFieldName);
                String label = labelJsonElement.getAsString();
                @SuppressWarnings("unchecked") // registration requires that subtype extends T
                        TypeAdapter<R> delegate = (TypeAdapter<R>) labelToDelegate.get(label);
                if (delegate == null) throw new JsonParseException(
                        "cannot deserialize " + baseType + " subtype named " + label
                                + "; did you forget to register a subtype?");
                return delegate.fromJsonTree(jsonElement);
            }

            @Override
            public void write(JsonWriter out, R value) throws IOException {
                Class<?> srcType = value.getClass();
                String label = subtypeToLabel.get(srcType);
                @SuppressWarnings("unchecked") // registration requires that subtype extends T
                        TypeAdapter<R> delegate = (TypeAdapter<R>) subtypeToDelegate.get(srcType);
                if (delegate == null) throw new JsonParseException(
                        "cannot serialize " + srcType.getName() + "; did you forget to register a subtype?");
                JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();
                if (jsonObject.has(typeFieldName)) throw new JsonParseException(
                        "cannot serialize " + srcType.getName() + " because it already defines a field named "
                                + typeFieldName);
                JsonObject clone = new JsonObject();
                clone.add(typeFieldName, new JsonPrimitive(label));
                for (Map.Entry<String, JsonElement> e : jsonObject.entrySet())
                    clone.add(e.getKey(), e.getValue());
                Streams.write(clone, out);
            }
        }.nullSafe();
    }
}
```
###### src\data\SettingManager.java
``` java

import common.ResetSettingsException;
import org.apache.commons.configuration2.Configuration;

public interface SettingManager {
    void resetDefaultSettings() throws ResetSettingsException;

    String getPathOfSaveFile();

    void setPathOfSaveFile(String absolutePathOfSaveFile);

    Configuration getConfigs();
}
```
###### src\data\SettingManagerImpl.java
``` java

import common.LoadSettingsException;
import common.ResetSettingsException;
import org.apache.commons.configuration2.Configuration;
import org.apache.commons.configuration2.FileBasedConfiguration;
import org.apache.commons.configuration2.PropertiesConfiguration;
import org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder;
import org.apache.commons.configuration2.builder.fluent.Configurations;
import org.apache.commons.configuration2.builder.fluent.Parameters;
import org.apache.commons.configuration2.builder.fluent.PropertiesBuilderParameters;
import org.apache.commons.configuration2.ex.ConfigurationException;

import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

public class SettingManagerImpl implements SettingManager {
    private static final String DEFAULT_FILENAME_OF_SETTING = "settings.properties";
    private static final Path DEFAULT_PATH_OF_SETTING = Paths.get(DEFAULT_FILENAME_OF_SETTING);
    private static final String SETTING_HEADER_TEXT = "Application Settings";
    private static final String DEFAULT_ENCODING = "UTF-8";
    private static final Logger logger = Logger.getLogger(SettingManagerImpl.class.getName());
    private Configuration settings;

    public SettingManagerImpl() {

        initiate();
    }

    private void initiate() {
        if (settingFileDoesNotExist()) createDefaultSettings();
        else if (!settingFileExistButEmpty()) loadSettings();
        else resetDefaultSettings();
    }

    @Override
    public void resetDefaultSettings() throws ResetSettingsException {
        try {
            Files.deleteIfExists(DEFAULT_PATH_OF_SETTING);
            createDefaultSettings();
        } catch (IOException e) {
            logger.log(Level.SEVERE, "IO exception occured trying to reset default setting.\n"
                            + "Exception might be thrown because createDefaults() method failed to write to file.",
                    e);
            throw new ResetSettingsException();
        }
    }

    @Override
    public String getPathOfSaveFile() {
        try {
            return settings.getString(AvailableSettings.SAVE_LOCATION.toString());
        } catch (NullPointerException e) {
            logger.log(Level.WARNING, "Setting stored in configuration object is :" + settings
                    .getString(AvailableSettings.SAVE_LOCATION.toString()), e);
            return null;
        }
    }

    @Override
    public void setPathOfSaveFile(String absolutePathOfSaveFile) {
        settings.setProperty(AvailableSettings.SAVE_LOCATION.toString(), absolutePathOfSaveFile);
        assert (absolutePathOfSaveFile.equals(settings.getString(AvailableSettings.SAVE_LOCATION.name())));
    }

    @Override
    public Configuration getConfigs() {
        return this.settings;
    }

    private boolean settingFileExistButEmpty() {
        assert Files.exists(DEFAULT_PATH_OF_SETTING);
        Configurations cons = new Configurations();
        try {
            return cons.properties(new File(DEFAULT_FILENAME_OF_SETTING)).isEmpty();
        } catch (ConfigurationException e) {
            e.printStackTrace();
            return false;
        }
    }

    private boolean settingFileDoesNotExist() {
        return Files.notExists(DEFAULT_PATH_OF_SETTING);
    }

    private void createDefaultSettings() {

        try (OutputStream outputStream = Files.newOutputStream(DEFAULT_PATH_OF_SETTING)) {
            Properties properties = new DefaultSettings().getDefaults();
            properties.store(outputStream, SETTING_HEADER_TEXT);
            loadSettings();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void loadSettings() throws LoadSettingsException {
        Parameters parameters = new Parameters();
        PropertiesBuilderParameters propertiesParams = parameters.properties()
                .setFileName(DEFAULT_FILENAME_OF_SETTING).setEncoding(DEFAULT_ENCODING);
        FileBasedConfigurationBuilder<FileBasedConfiguration> builder = new FileBasedConfigurationBuilder<FileBasedConfiguration>(
                PropertiesConfiguration.class).configure(propertiesParams);
        builder.setAutoSave(true);
        try {
            settings = builder.getConfiguration();
        } catch (ConfigurationException cex) {
            throw new LoadSettingsException();
        }
    }
}
```
###### src\model\Task.java
``` java
    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof Task)) return false;
        Task task = (Task) o;
        return id.equals(task.id) && taskName.equals(task.taskName) && !(endDate == null ?
                task.endDate != null :
                !endDate.equals(task.endDate)) && (startDate == null ?
                task.startDate == null :
                startDate.equals(task.startDate));
    }

    @Override
    public int hashCode() {
        return 31 * ((startDate == null ? 0 : startDate.hashCode()) + 31 * (31 * taskName.hashCode() + (
                endDate == null ?
                        0 :
                        endDate.hashCode()))) + id.hashCode();
    }

```
###### src\ui\controller\MainWindowController.java
``` java
import com.jfoenix.controls.JFXBadge;
import com.jfoenix.controls.JFXListView;
import com.jfoenix.controls.JFXSnackbar;
import com.jfoenix.controls.JFXTextField;
import common.InvalidStringException;
import common.UIOperationException;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.SelectionMode;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Modality;
import javafx.stage.Stage;
import logic.Logic;
import model.RecurringTask;
import model.Task;
import parser.*;
import ui.model.TaskListCell;

import java.io.IOException;
import java.net.URL;
import java.util.EmptyStackException;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;

import static ui.controller.TaskDoneEvent.TASK_COMPLETE;


public class MainWindowController implements Initializable {

    static Logger logger;
    private final UiOperationDelegator uiOperationDelegator = new UiOperationDelegator(this);
    private Main main;
    private Stage stage;
    private final UserInputParser parser = new UserInputParser();
    private final UpdateParser updateParser = new UpdateParser();
    private final RecurringParser recurringParser = new RecurringParser();
    private final DirectoryParser directoryParser = new DirectoryParser();
    private final SearchParser searchParser = new SearchParser();
    private final InputValidator inputValidator = new InputValidator();
    private final Logic operations = new Logic();
    private SearchHelper search = new SearchHelper();

    @FXML private AnchorPane mainContentContainer;
    @FXML private JFXBadge tasksCounter;
    @FXML private JFXTextField commandBox;
    @FXML private JFXListView<Task> printedPlanner;

    @FXML private JFXSnackbar snackbar;
    @FXML private Label headerTitle;

    private ObservableList<Task> plannerEntries;
    private ObservableList<Task> filteredEntries;

    private Stage helpStage;

    /**
     * Display messages as visual feedback for users.
     */
```
###### src\ui\controller\MainWindowController.java
``` java
    private void initPlanner() {
        plannerEntries = FXCollections.observableArrayList(operations.getTasks());
        printedPlanner.setItems(plannerEntries);
        printedPlanner.setDepthProperty(1);
        snackbar.registerSnackbarContainer(mainContentContainer);
        tasksCounter.setText(plannerEntries.size() + "");
        commandBox.requestFocus();
    }

```
###### src\ui\controller\MainWindowController.java
``` java
    void setStage(Stage s) {
        this.stage = s;
    }

    public void setMain(Main m) {
        this.main = m;
    }

    protected boolean isEmptyInput(String input) {
        return input == null || input.isEmpty() || "".equals(input.trim());
    }

    private boolean enterKeyIsPressed(KeyEvent e) {
        return KeyCode.ENTER.equals(e.getCode());
    }

    // This method will log the user input, as well as passes valid input to the performOperations method
    @FXML
    private void handleEnterKeyPressed(KeyEvent event) {
        String userInput = commandBox.getText();
        if (isEmptyInput(userInput) || !enterKeyIsPressed(event)) return;
        logger.log(Level.INFO, "User typed in : <" + userInput + "> command string");
        try {
            uiOperationDelegator.performOperations(userInput);
        } catch (UIOperationException e) {
            logger.log(Level.SEVERE,
                    "Error occured at " + getClass().getName() + " within performOperation method.\n");
            e.printStackTrace();
        } catch (InvalidStringException e) {
            displayMessage(ERROR_MESSAGE_FOR_INVALID_INPUT);
        }
    }

```
###### src\ui\controller\MainWindowController.java
``` java
    void showAll() {
        plannerEntries = FXCollections.observableArrayList(operations.getTasks());
        afterOperation();
        headerTitle.setText("Tasks: All");
        setGenericIcon();
        updateTaskCounter();
        commandBox.clear();
    }

    void showToday() {

        printedPlanner.setItems(plannerEntries.filtered(task -> search.isItDisplayedInTodayView(task)));
        headerTitle.setText("Tasks: Today + Floating");
        setGenericIcon();
        updateTaskCounter();
        commandBox.clear();
    }
    private void updateTaskCounter() {
        tasksCounter.setText(printedPlanner.getItems().size() + "");
    }
    private void setUpDisplay() {
        setGenericIcon();
        updateTaskCounter();
        commandBox.clear();
    }
    void changeTheme(String userInput) {
        Scene scene = main.getScene();
        ThemeChanger themer = new ThemeChanger();
        Platform.runLater(() -> {
            try {
                themer.change(userInput, scene);
                commandBox.clear();
            } catch (Exception e) {
                logger.warning("Thread Exception occurred trying to set element property" + e.toString());
            }
        });
    }

    void searchTask(String userInput) throws Exception {

        if (search.isKeywordSearch()) {
            String taskName = parser.getTaskName(userInput);
            headerTitle.setText("Search Results  \"" + taskName + "\":");
            printedPlanner.setItems(plannerEntries.filtered(task -> search.containsKeyWord(task, taskName)));
            updateTaskCounter();
        }

        commandBox.clear();
    }
```
###### src\ui\controller\MainWindowController.java
``` java
    private javafx.concurrent.Task<Void> makeSleeper(int duration) {
        return new javafx.concurrent.Task<Void>() {
            @Override
            protected Void call() throws Exception {
                try {
                    Thread.sleep(duration);
                } catch (InterruptedException e) {
                    // do nothing. handles library bug
                }
                return null;
            }
        };
    }

```
###### src\ui\controller\MainWindowController.java
``` java
    void changeDirectory(String userInput) throws Exception {
        operations.changeDir(directoryParser.getFilePath(userInput));
        afterOperation();
    }

```
###### src\ui\controller\MainWindowController.java
``` java
    private void displayMessage(String message) {
        snackbar.fireEvent(new JFXSnackbar.SnackbarEvent(message, "", 1500, (b) -> {
        }));
    }
    private void refresh() {
        printedPlanner.setItems(plannerEntries);
    }
    private void setCellFactory() {
        printedPlanner.setCellFactory(param -> {
            TaskListCell listCell = new TaskListCell();
            printedPlanner.addEventFilter(TASK_COMPLETE, event -> new Thread(() -> {
                Thread.currentThread().setUncaughtExceptionHandler((task, e) -> Platform.runLater(
                        () -> logger.info("JFonix library throws exception when accessing checkbox from different thread.\n"
                                + " Would be fixed when library release new version")));
                fireCheckBoxAndRemoveEventFilter(listCell, event);
            }).start());
            return listCell;
        });
    }

    private void fireCheckBoxAndRemoveEventFilter(TaskListCell c, TaskDoneEvent e) {
        if (listCellContainsSelectedTask(c, e)) {
            c.getCheckBox().fire();
            javafx.concurrent.Task<Void> sleeper = makeSleeper(500);
            sleeper.setOnSucceeded(evt -> {
                printedPlanner.getSelectionModel().clearSelection();
                plannerEntries.remove(e.getTask());
                operations.markAsDone(e.getTask().getId());
                commandBox.clear();
                afterOperation();
            });
            new Thread(sleeper).start();
        }
        c.removeEventFilter(TASK_COMPLETE, null);
    }

    private boolean listCellContainsSelectedTask(TaskListCell c, TaskDoneEvent e) {
        return c.getTask().equals(e.getTask());
    }

    public Logic getOperations() {
        return operations;
    }

    public UserInputParser getParser() {
        return parser;
    }
}
```
###### src\ui\controller\SearchHelper.java
``` java
    public boolean containsKeyWord(Task t, String keywords) {
        String[] keywWordsArr = keywords.split("\\s+");
        processKeyWords(keywWordsArr);
        return containsFuzzy(keywWordsArr, t.getName());
    }
```
###### src\ui\controller\SearchHelper.java
``` java

    private void processKeyWords(String[] keywords) {
        for (String s : keywords) {
            s = s.trim();
            s = s.toLowerCase();
        }
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    private boolean containsFuzzy(String[] keywords, String taskName) {
        for (String s : keywords)
            if (taskName.contains(s) || compareStrings(taskName, s) > FUZZY_STRING_COMPARE_THRESHOLD)
                return true;
        return false;
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    private double compareStrings(String source, String toBeCompared) {
        return StringUtils.getJaroWinklerDistance(source, toBeCompared);
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    public boolean isFloatingTask(Task t) {
        return FLOATING_TASK.equals(t.getTaskType());
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    private boolean isDueToday(Task t) {
        return t.getDueDate().isEqual(LocalDate.now());
    }

```
###### src\ui\controller\SearchHelper.java
``` java
    boolean isKeywordSearch() {
        return true;
    }

```
###### src\ui\controller\TaskDoneEvent.java
``` java

import javafx.event.Event;
import javafx.event.EventTarget;
import javafx.event.EventType;
import model.Task;

public class TaskDoneEvent extends Event {

    public static final EventType<TaskDoneEvent> TASK_COMPLETE = new EventType(ANY, "TASK_COMPLETE");

    private Task task;

    public TaskDoneEvent(Task task) {
        this(TASK_COMPLETE);
        this.task = task;
    }

    public Task getTask() {
        return task;
    }

    public TaskDoneEvent(EventType<? extends Event> arg0) {
        super(arg0);
    }

    public TaskDoneEvent(Object arg0, EventTarget arg1, EventType<? extends Event> arg2) {
        super(arg0, arg1, arg2);
    }
}
```
###### src\ui\model\TaskListCell.java
``` java
import com.jfoenix.controls.JFXCheckBox;
import com.jfoenix.controls.JFXListCell;
import com.jfoenix.controls.JFXRippler;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.scene.control.Label;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import model.Task;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

public class TaskListCell extends JFXListCell<Task> {

    private final Label taskStartDate = new Label();
    private final Label taskDueDate = new Label();
    private final Label taskName = new Label();
    private final Label taskStartTime = new Label();
    private final Label taskEndTime = new Label();
    private final Label taskId = new Label();
    private final JFXCheckBox checkBox = new JFXCheckBox();
    private final GridPane grid = new GridPane();
    private JFXRippler rippler = new JFXRippler();
    private Task myTask;

    public TaskListCell() {
        configureGrid();
        configureTaskName();
        configureDate();
        configureTime();
        configureCheckBox();
        addControlsToGrid();
        addGridToRippler();
    }

    @Override
    public void updateItem(Task t, boolean empty) {
        super.updateItem(t, empty);
        if (empty) clearContent();
        else updateContent(t);
    }

    private void addGridToRippler() {
        rippler.setControl(grid);
    }

    private void configureGrid() {
        grid.setHgap(10);
        grid.setVgap(5);
        grid.setPadding(new Insets(0, 10, 0, 10));
        ColumnConstraints column1 = new ColumnConstraints();
        column1.setMinWidth(20);
        column1.setMaxWidth(20);
        ColumnConstraints column2 = new ColumnConstraints();
        column2.setMaxWidth(20);
        ColumnConstraints column3 = new ColumnConstraints();
        column3.setHgrow(Priority.ALWAYS);
        ColumnConstraints column4 = new ColumnConstraints();
        column4.setMinWidth(80);
        ColumnConstraints column5 = new ColumnConstraints();
        column5.setMinWidth(80);
        grid.getColumnConstraints().addAll(column1, column2, column3, column4, column5);
    }

    protected void addContent(Task t) {
        setTaskName(t);
        setTaskId(t);
        setTaskStartDate(t);
        setTaskEndDate(t);
        setTaskStartTime(t);
        setTaskEndTime(t);
        setGraphic(grid);
    }

    private void updateContent(Task t) {
        this.myTask = t;
        addContent(t);
        rippler = new JFXRippler(grid);
        setGraphic(rippler);
    }

    private void addControlsToGrid() {
        grid.add(taskId, 0, 0, 1, 2);
        grid.add(checkBox, 1, 0, 1, 2);
        grid.add(new HBox(taskName), 2, 0, 1, 2);
        grid.add(taskStartDate, 3, 0);
        grid.add(taskStartTime, 3, 1);
        grid.add(taskDueDate, 4, 0);
        grid.add(taskEndTime, 4, 1);
    }

    private void configureTime() {
        taskStartDate.getStyleClass().add("task-time");
        taskEndTime.getStyleClass().add("task-time");
        GridPane.setHalignment(taskStartTime, HPos.RIGHT);
        GridPane.setHalignment(taskEndTime, HPos.RIGHT);
    }

    private void configureTaskName() {
        setWrapIfTaskNameLong();
        taskName.getStyleClass().add("task-name");
    }

    private void configureDate() {
        taskStartDate.getStyleClass().add("task-date");
        taskDueDate.getStyleClass().add("task-date");
        GridPane.setHalignment(taskStartDate, HPos.RIGHT);
        GridPane.setHalignment(taskDueDate, HPos.RIGHT);
    }

    private void configureCheckBox() {
        checkBox.getStyleClass().add("task-check-box");
    }

    private void clearContent() {
        setText(null);
        setGraphic(null);
    }

    protected void setTaskId(Task t) {
        taskId.setText(String.valueOf(getIndex() + 1));
    }

    protected void setTaskName(Task t) {
        taskName.setText(t.getName());
    }

    protected void setTaskStartDate(Task t) {
        if (t != null && t.getStartDate() != null && !t.getStartDate().equals(LocalDate.MIN))
            setStartDateInText(t);
        else taskStartDate.setText("");
    }

    private void setStartDateInText(Task t) {
        taskStartDate.setText(DateTimeFormatter.ofPattern("dd MMM yyyy").format(t.getStartDate()));
    }

    private boolean isNotFloatingTask(Task t) {
        return !"floating".equals(t.getTaskType());
    }

    protected void setTaskEndDate(Task t) {

        taskDueDate.setText(t == null || t.getDueDate() == null || t.getDueDate().equals(LocalDate.MAX) ?
                "-" :
                DateTimeFormatter.ofPattern("dd MMM yyyy").format(t.getDueDate()));
    }

```
###### src\ui\model\TaskListCell.java
``` java
    private boolean timeCheck(Task t) {
        return t.getStartTime() != null || t.getEndTime() != null;
    }

    private boolean isNotEvent(Task t) {
        return !"wholeDayEvent".equals(t.getTaskType());
    }

    public JFXCheckBox getCheckBox() {
        return checkBox;
    }

    public Task getTask() {
        return myTask;
    }

    private void setWrapIfTaskNameLong() {
        taskName.setWrapText(true);
        setPrefWidth(0);
    }

}
```
###### tests\data\JsonDataHandlerTest.java
``` java

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import model.RecurringTask;
import model.Task;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.*;

public class JsonDataHandlerTest {
    private JsonDataHandler dataHandler;
    private List<Task> plannerNotebook;
    public static final String WORKING_DIRECTORY = System.getProperty("user.dir");
    public static final String PATH_SEPARATOR = System.getProperty("file.separator");
    public static final String FILE_NAME = "test.json";

    @Before
    public void setUp() throws Exception {
        plannerNotebook = new ArrayList<>();
        dataHandler = new JsonDataHandler();
        dataHandler.setSavePath(FILE_NAME);
    }

    @After
    public void tearDown() {
        dataHandler.reset();
        cleanUpFiles();

    }

    private void cleanUpFiles() {
        try {
            Files.deleteIfExists(dataHandler.getFilePath());
        } catch (IOException e) {
            System.out.println("Cannot delete test files.");
        }
    }

    @Test
    public void whenNewHandlerCreatedPathShouldNotBeNull() {
        assertNotNull(dataHandler.getFilePath());
    }

    @Test
    public void ifThereIsNoSaveFileCreateDefaultBasedOnSettingsFileName() throws IOException {
        Files.deleteIfExists(dataHandler.getFilePath());
        dataHandler = new JsonDataHandler();
        assertTrue(hasSaveFile());
    }

    @Test
    public void canSaveListOfTasksToJsonFile() {
        List<Task> tasks = createTasksWithStartAndEnd(20);
        dataHandler.save(tasks);
        try {
            BufferedReader reader = Files.newBufferedReader(dataHandler.getFilePath());
            Gson gson = getGson();
            List<Task> testObj = gson.fromJson(reader, new TypeToken<List<Task>>() {}.getType());
            assertEquals(testObj, tasks);
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void canSaveOneTaskIntoJsonFile() {
        String taskName = "Task 1";
        Task testTask = new Task(taskName, LocalDate.now(), LocalDate.now());
        dataHandler.save(testTask);
        assertEquals(testTask, readOneTask());
    }

    @Test
    public void canReadsavedTasksFromJsonFile() {
        plannerNotebook = create30TasksWithDifferentAttributes();
        dataHandler.save(plannerNotebook);
        assertEquals(plannerNotebook, dataHandler.getTasks());
    }

    @Test
    public void canSaveOneRecurrTask() {

        RecurringTask task = new RecurringTask("RecurringTask11", LocalDate.MIN, LocalDate.MAX, "week",
                LocalTime.NOON, LocalTime.now(), 1);
        List<Task> tasks = new ArrayList<>();
        tasks.add(task);
        dataHandler.save(tasks);
        assertEquals(dataHandler.getTasks().get(0).getName(), task.getName());
    }

    @Test
    public void ifTaskSaveFileHasNoTaskGetTasksShouldNotReturnNull() throws IOException {
        dataHandler.reset();
        assertNotNull(dataHandler.getTasks());
    }

    @Test
    public void deserializedRecurringTasksShouldHaveCorrectType() {
        Task t = new RecurringTask("task1", LocalDate.now(), LocalDate.now(), "week", LocalTime.NOON,
                LocalTime.MIDNIGHT, 1);
        List<Task> tasks = new ArrayList<>();
        tasks.add(t);
        dataHandler.save(tasks);
        dataHandler.getTasks().get(0);
        assertEquals(RecurringTask.class, dataHandler.getTasks().get(0).getClass());
    }

    @Test
    public void allDeserializedTasksShouldBeEqualToOriginal() {
        List<Task> tasks = create30TasksWithDifferentAttributes();
        Object[] taskArr = tasks.toArray();
        dataHandler.save(tasks);

        assertArrayEquals(taskArr, dataHandler.getTasks().toArray());

    }

    @Test
    public void deserilizedTasksShouldHaveCorrectType() {
        List<Task> expected = create30TasksWithDifferentAttributes(); // last 10 are recurr tasks
        dataHandler.save(expected);
        List<Task> result = dataHandler.getTasks();
        for (int i = 0; i < expected.size(); ++i)
            assertEquals(expected.get(i).getClass(), result.get(i).getClass());
    }

    @Test
    public void deserilizedRecurTaskShouldContainTypeAttribute() {
        List<Task> expected = create30TasksWithDifferentAttributes();
        dataHandler.save(expected);
        List<Task> result = dataHandler.getTasks();

        for (int i = 20; i < expected.size(); ++i)
            assertEquals(((RecurringTask) result.get(i)).getClass(),
                    ((RecurringTask) expected.get(i)).getClass());

    }

    @Test
    public void saveSaveFileToExistingDirectory() {
        List<Task> tasks = create30TasksWithDifferentAttributes();
        dataHandler.setSavePath(WORKING_DIRECTORY + PATH_SEPARATOR + FILE_NAME);
        System.out.println(dataHandler.getFilePath());
        dataHandler.save(tasks);
    }

    @Test
    public void canSaveFileToNewDir() {
        String path = "c:" + PATH_SEPARATOR + "temp" + PATH_SEPARATOR + FILE_NAME;
        System.out.println(path);
        List<Task> tasks = create30TasksWithDifferentAttributes();
        dataHandler.setSavePath(path);
        dataHandler.save(tasks);
        assertTrue(Files.exists(Paths.get(path)));
    }

    private Task readOneTask() {
        try {
            BufferedReader reader = Files.newBufferedReader(dataHandler.getFilePath());
            Gson gson = getGson();
            Task $ = gson.fromJson(reader, Task.class);
            reader.close();
            return $;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    private List<Task> create30TasksWithDifferentAttributes() {
        List<Task> $ = new ArrayList<Task>(createTasksWithStartAndEnd(10));
        $.addAll(createTasksWithOnlyTaskNameAttribute(10));
        $.addAll(createRecurringTasks(10));
        return $;
    }

    private List<Task> createRecurringTasks(int numberOfTasks) {
        List<Task> $ = new ArrayList<>();
        for (int i = 0; i < numberOfTasks; ++i)
            $.add((new RecurringTask(("Recurring Task " + i), LocalDate.now(), LocalDate.now().plusMonths(1),
                    "week", LocalTime.NOON, LocalTime.MIDNIGHT, 1)));
        return $;
    }

    private List<Task> createTasksWithOnlyTaskNameAttribute(int numberOfTasks) {
        List<Task> $ = new ArrayList<>();
        for (int i = 0; i < numberOfTasks; ++i)
            $.add((new Task(("Task " + i))));
        return $;
    }

    private List<Task> createTasksWithStartAndEnd(int numberOfTasks) {
        List<Task> $ = new ArrayList<>();
        for (int i = 0; i < numberOfTasks; ++i)
            $.add((new Task(("Task " + i), LocalDate.now(), LocalDate.now())));
        return $;
    }

    private boolean hasSaveFile() {
        return Files.exists(dataHandler.getFilePath());
    }

    private Gson getGson() {
        return new GsonBuilder().setPrettyPrinting().registerTypeAdapterFactory(
                RuntimeTypeAdapterFactory.of(Task.class).registerSubtype(Task.class, "Task")
                        .registerSubtype(RecurringTask.class, "RecurringTask")).create();
    }

}
```
###### tests\data\SettingManagerTest.java
``` java

import org.apache.commons.configuration2.Configuration;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.File;

import static org.junit.Assert.*;

public class SettingManagerTest {
    private SettingManager settingManager;
    private static final File file = new File("settings.properties");

    @Before
    public void setUp() throws Exception {
        settingManager = new SettingManagerImpl();
    }

    @After
    public void tearDown() {
        settingManager.resetDefaultSettings();
    }

    @Test
    public void settingsFileShouldAlwaysExist() {
        assertTrue(file.exists());
    }

    @Test
    public void ifSettingsFileIsEmptyShouldSetDefault() {
        Configuration settings = null;
        removeEverythingFromSettingsFile();
        settingManager = new SettingManagerImpl();
        settings = settingManager.getConfigs();
        assertFalse(settings.isEmpty());
    }

    @Test
    public void canChangeDirectorySettings() {
        String expectedPath = "..desktop";
        settingManager.setPathOfSaveFile(expectedPath);
        assertEquals(expectedPath, settingManager.getPathOfSaveFile());
    }

    private void removeEverythingFromSettingsFile() {
        Configuration settings = settingManager.getConfigs();
        settings.clear();
    }

}
```
###### tests\TestRunner.java
``` java
public class TestRunner {
    public static final String ANSI_RESET = "\u001B[0m";
    public static final String ANSI_BLACK = "\u001B[30m";
    public static final String ANSI_RED = "\u001B[31m";
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_YELLOW = "\u001B[33m";
    public static final String ANSI_BLUE = "\u001B[34m";
    public static final String ANSI_PURPLE = "\u001B[35m";
    public static final String ANSI_CYAN = "\u001B[36m";
    public static final String ANSI_WHITE = "\u001B[37m";

    public static void main(String[] args) {
        Result result = JUnitCore
                .runClasses(JsonDataHandlerTest.class, SettingManagerTest.class, AddTaskTest.class,
                        DeleteTaskTest.class, LogicTest.class, SkipRecurTaskTest.class, UpdateTaskTest.class,
                        RecurringTaskTest.class, DateTimeParserTest.class, UserInputParserTest.class,
                        UpdateParserTest.class, UserInputParserTest.class, TaskListCellTest.class);

        System.out.println();

        System.out.println(ANSI_GREEN + "Run count: " + result.getRunCount() + ANSI_RESET);
        System.out.println(ANSI_GREEN + "Run time: " + result.getRunTime() + ANSI_RESET);
        System.out.println(ANSI_CYAN + "===================================" + ANSI_RESET);
        if (result.wasSuccessful()) {
            System.out.println(ANSI_BLUE + "Wohooooo you passed all those tests!" + ANSI_RESET);
        } else {
            List<Failure> failures = result.getFailures();
            for (Failure f : failures) {
                System.out.println(ANSI_RED + f + ANSI_RESET);
            }
        }
    }
}
```
